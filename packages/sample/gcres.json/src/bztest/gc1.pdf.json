{
  "prompt": [
    {
      "role": "system",
      "content": "---\nYou are concise. Answer in markdown.\n\n---\nWhen explaining answers, take a deep breath.\n\n---\n## Files\n\nWhen generating or updating files you will use the following syntax:\nMake sure to use precisely ``` to guard file code sections.\nMake sure to use precisely ````` to guard file markdown sections.\nUse full path of filename in code section header.\nIf a file does not have changes, do not regenerate.\nDo NOT emit line numbers in file.\nCSV files are inlined as markdown tables.\n\n"
    },
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "DOCS:\n```pdf file=\"src/bztest/gc1.pdf\"\nM . D. M c l L R O Y , Editor\n\n2. S t a t e m e n t o f t h e P r o b l e m a n d R e v i e w o f P a s t\nAn Efficient Machine-Independent\nS o l u t i o n s\nProcedure for Garbage Collection\nThe major problem which arises when attempting to re-\nclaim a part of a list structure is that of knowing which\nin Various List Structures\npart is no longer needed. This has received considerable\nattention in the literature [1-8] and three solutions have\nH. S C H O R R\nbeen proposed. The first, by Newell, Simon and Shaw [1],\nI B M Corp., Menlo Parle, California\nplaces the responsibility on the programmer. Their lan-\nAND\nguage (IPL-V) includes instructions which cause lists and\nW. M. WAITE\nlist structures to be erased, thereby returning their registers\nUniversity of Colorado,* Boulder, Colorado\nto the free list. This approach is unattractive because it\nrequires the programmer to keep track of the status of lists,\nsublists, etc. For example, part of a list m a y be shared with\nseveral other lists and might still be needed, while the re-\nmainder could be erased.\nA second solution for systems which use shared sublists,\noriginally due to Gerlernter et al. [3], extended by Collins\n[4], and used by Weizenbaum [5, 6], requires keeping a\nA method for returning registers to the free list is an essen-\ncount of the references made to a list and salvaging the\ntial part of any list processing system. In this paper, past\nregisters when the count reaches zero. In a one-way list\nsolutions of the recovery problem are reviewed and com-\nstructure it is impossible to locate the head of a list when a\npared. A new algorithm is presented which offers significant\nreference is made to some register along the list. Thus the\nadvantages of speed and storage utilization. The routine for\npart which starts from the referenced register must be\nimplementing this algorithm can be written in the list language\ntreated as a new list, and a new reference counter must be\nwith which it is to be used, thus insuring a degree of machine\nset up. T h e proliferation of reference counters, and\nindependence. Finally, the application of the algorithm to a\nthe large amount of bookkeeping involved, makes this\nnumber of different list structures appearing in the literature is\nmethod extremely cumbersome. In a two-way list [6] it is\nindicated.\nahvays possible to locate the head, and thus it is not neces-\n1. I n t r o d u c t i o n\nsary to set up a new reference counter. However, the head\nof the list must be found and the reference count increased\nOne of the most important features of a list language is\nby 1. Besides being time-consuming, this may prevent re-\nits ability to allocate storage dynamically during the run-\nturning part of a list to the free list. For example, in Figure\nning of the object program. This is accomplished by means\n1 there is no way of discarding the top part of list B if list\nof a list of\navailable space (or free list) which contains those\nA still needs the bottom part of B. Thus in practice this\nregisters not being used. Initially, the free list contains all\nstorage not occupied by the program [1, 2, 11], and regis-\npart of B has to be treated as a separate list and a new\nters are detached from it and formed into list structures\nreference counter is needed [5, 6]. T h e reference counter\nas the program is executed. T h e execution of the program\nmethod breaks down completely in the case of a circular\nmust usually be suspended when the free list is exhausted,\nlist (i.e., one in which the list is a sublist of itself). In this\nand the problem arises of reclaiming those parts of the list\nsituation the reference counter cannot be decreased to zero,\nstructure which are no longer needed (if any such exist). In\neven though the entire list m a y become inaccessible [13].\nthis paper a statement of the difficulties involved is fol-\nT h e third solution, which appears to be the most attrac-\nlowed by a brief review of the solutions which have been\ntive, was proposed by M c C a r t h y [2] and is considered in\nproposed. A new, machine-independent procedure and the\ndetail below. In this method, no reference counters are\nresults obtained using the 7094 version of this procedure\nkept and registers are not returned to the free list until the\nare presented. Finally, the application and modification of\nlatter has been exhausted. T h e n a procedure known as\nthis routine for a variety of list structures is discussed.\n\"garbage collection\" is initiated, which traces the entire\n* Department of Electrical Engineering\nlist structure, marking those registers which are attached\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 501\n\n-------- Page Break --------\n\nto some list. Registers no longer needed will not be attached\nwords making up such an element can be allowed to vary\nto any list and will thus remain unmarked. When all lists\nfrom element to element. These variable-length elements\nhave been traced, a routine is entered to form all unmarked\nwere proposed by Comfort [9], who also gave a solution to\nregisters into a new free list and erase the marks in all\nthe problem which is created of maintaining a generalized\nothers (in ease the garbage collector has to be used again\nfree list. In such a free list, an item of arbitrary length m a y\nlater).\nbe taken off, and to insure t h a t large elements are available\nSeveral difficulties arise in using and implementing a\nit is important to t r y to reconstruct the largest possible\ngarbage collection procedure.\nblocks of consecutive free registers when returning regis-\n(A) T h e basic problem is the tracing of the lists. In\nters to the free list. The problem of using a garbage collee-\ngeneral the lists will be branched and all branches must be\ntion procedure to achieve this is discussed below.\ntraced. Several methods have been suggested, but all re-\n3. A T e c h n i q u e for G a r b a g e C o l l e c t i o n i n a O n e -\nquire either a significant amount of additional storage (for\nW a y L i s t\nremembering the branch points encountered) or the re-\ntracing of large portions of the list structure m a n y times.    Solution of the basic problem (see Section 2A) of garbage\ncollection requires a routine t h a t is economical both in its\n(B) A second problem arises when the data consists of\nsigned numbers which are stored in a whole word. In  use of temporary storage and in the number of times it\ntraverses the list structure. In addition, of course, it must\nMcCarthy's method of garbage collection, the sign of each\nregister that is attached to a list is set to minus, while un-  be able to trace any possible list. A routine which uses a\nlimited amount of temporary storage for remembering the\nattached registers remain positive. The sign of an attached\nlocation of branch points cannot trace a list which has too\nregister is then reset to plus after the new free list has been\nm a n y such points, and a reeursive routine requires a push-\nformed. Clearly, this procedure, unless modified, will result\nin reversing the sign of any negative numbers. The modifi- down stack of indeterminate length on which to store re-\nturn addresses. Moreover, if a routine must traverse a par-\ncation proposed by M c C a r t h y is to reserve a block of stor-\ntieular list an indeterminate number of times it will fail\nage t h a t is to be used exclusively for whole-word data items\nwhen it encounters a circular list. In connection with an\n(full-word space). A second part of the store is then set aside\nimplementation of the Wisp language [7, S] for the I B M\nfor a bit table, to be used during garbage collection to re-\n7094, a method has been developed which uses two index\ncord which of the full words are still part of active list\nregisters and the accumulator for temporary storage and\nstructures. This modification is not completely satisfactory\nwhich traverses the list structure twice. This routine is\nsince (1) it violates the dynamic storage allocation princi-\ncapable of tracing any list structure (including circu-\nple of list processing languages, and (2) the storage used\nlar lists) which has any number of branch points.\nby the bit table and the additional part of the garbage\nIn the Wisp system as programmed for the 7094, the\ncollection program which utilizes it must be taken away\naddress field (TAIL) of a list element contains the loca-\nfrom the free list.\ntion of the next register on the list and is called a pointer.\n(C) Besides single full-word data items, multiple-word\nT h e decrement field (HEAD) contains either an atom [2]\nlist elements have been proposed, and the number of\nor the location of a branch of the list. A Wise list is shown\nin Figure 2(a). T h e prefix and tag fields are unused and\nhence are available for use by the garbage collector. T h e\nB\nalgorithm employed here is to move down a list ignoring\nsublists and reversing the pointers as one goes. This re-\nversal of pointers in a one-way list structure with shared\nsublists permits a return to be made to the head of a list\nduring garbage collection. During this first pass, the sign\nof each register is made negative. T h e end of the first pass\ni\nis reached when either (1) the end of the list is reached, or\n(2) a register on the list is encountered whose sign is minus\n(indicating that this part of the list is a sublist of some\ni t\nother list that has already been traversed). T h e result of\napplying this forward scan to the list D shown in Figure\n2(a) is given in Figure 2(b).\n1 I\nDuring the forward scan of the list, the contents of the\nH E A D of each list register are ignored. T h e reverse scan,\nwhich is entered when the forward scan is terminated,\nI i\nmoves back up the list restoring the original pointers. ID\naddition, it examines the H E A D of each register, checking\nto see if it contains a reference to a sublist. (In the 7094\nimplementation of WisP, any number larger than 2200 is a\npointer to a sublist, while any number less than this is an\nFiG. 1. Sharing a sublist in a two-way list structure\n\n502 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\n\n\n-------- Page Break --------\n\nnominal--68 words for the routine itself, in addition to the\n4. T h e R o u t i n e a n d its E f f i c i e n c y\ntwo index registers and accumulator.\nT h e routine itself is flowcharted in Figure 3. For con-\nFor purposes of comparison, a trace routine proposed by\nvenience in drawing the flowchart, the list elements are\nWilkes was coded for the 7094. I t required only two tempo-\nassumed to be numbered sequentially. Thus, list element\nrary storage locations, and occupied 35 words of memory.\nI + 1 follows list element I (i.e., list element I + 1 is pointed\nThis routine traversed a path from the head of a list to each\nto by the T A I L of list element I). T h e routine uses two in-\nterminal register separately. Thus much of the list was\ndex registers and the accumulator for temporary storage,\nscanned m a n y times, and the program would fail by enter-\nthough in general any three storage locations could be used.\ning a loop when attempting to trace a circular list. When\nOne contains the address of the previous list element ex-\nrun under the above conditions (5 binary trees of depth 12)\namined, the second the address of the element currently\nthe routine required 2.75 seconds for a complete trace.\nbeing examined and the third the address of the next ele-\nAs a final comparison, a routine which stored branch\nment on the list. This is necessary for the reversal of the\npoints was coded and run using the same list structure. T h e\npointers during the forward scan and their restoration\nprogram occupied 34 words, and an additional 48 words\nduring the reverse scan.\nwere allotted as a storage area for the branch points. Any\nIn order to evaluate the speed of the routine, a Wise\ngiven part of the list structure was only traversed once, so\nprogram was written which created five complete binary\nt h a t this routine could trace any list for which the number\ntrees of depth 12. T h e remaining registers were discarded\nof branch points it was required to store was less t h a n 49.\nand the garbage collector called. Thus it was forced to\nOnly .448 seconds were required to complete the trace of\ntrace a list structure containing over 20,000 registers, half\nthe test structure.\nof which were branch points. T h e elapsed time, according\nto the system clock, was 1.85 seconds. This list structure\nseems far more complex than any which would be en-\ncountered in practice, and therefore a normal garbage col-\nlection should take far less time. T h e space occupied is also\n\nENTRY\nYES\n\ni\n\nSET I TO I\ni\nFIRST CELL\nOF L ST\nEXIT\n\nQ\nYES\n\nRESTORE POINTER\nlNO\nRESTORE POINTER\nIN CAR OFI.\nOF CELL I\nCLEAR BRANCH\nI - ~ I\nPOINT FLAG.\nL\nI MAKE'TI\nMINUS\n\nF\nNO\n1\nI REVERSE POINTER\nOFCELLI\nW:l  ~~~iYESTO\nREVERSE POINTERI\nIN CAR OF I\nSET BRANCH\nPO NT FLAG\n\n1\nSET 2: TO\nYES\nFIRST CELL\nOF BRANCH\n\n(\nFIG. 3. T r a c e a l g o r i t h m f o r a o n e - w a y l i s t . F o r w a r d s c a n ; r e v e r s e s c a n\n\n504 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\nreturned. To see this, consider first the way in which the\nOn the basis of these results, it seems that the best gar-\nfree list is originally formed. If all of the unused storage\nbage collection procedure is to use the last routine with as\nconstitutes a consecutive block [11], then the free list can be\nmuch temporary storage as possible, and when this storage\nconstructed so t h a t a new free list element occurs at every\nis full to trace the remainder of the current branch using\nn t h memory address from the start of the block. Thus it\nthe algorithm given in Section 4. In this way one is able to\nsuffices to look at the every n t h location in the free storage\nrealize the most efficient collection for the amount of tem-\nspace; a positive register and the succeeding n - 1 registers\nporary memory available, and yet there is no possibility\ncan be returned to the free list.\nof failure for any structure. If, however, no temporary\nConsider next, garbage collection when n can vary from\nstorage area can be excluded from the free list or it is in-\none list element to the next. In this case, the H E A D of the\nconvenient to code two garbage collectors, then the al-\nfirst register does not ordinarily contain data, but rather\ngorithm of the previous section offers a reasonably efficient\ncontains the number n of registers that make up the ele-\nfail-safe solution.\nment. It is necessary then to distinguish between the fol-\n5. S y m b o l i c G a r b a g e C o l l e c t o r\nlowing items that m a y occupy the H E A D : (1) the number\nThe transfer of a programming system from one machine\nn, as above, of consecutive registers, for n > 1, and (2) the\nto another can be more easily achieved if the compiler and\ndata item itself (which m a y be a pointer to a sublist) if\nits utility routines are written in a higher level (nonma-\nn = l .\nchine) language [7, 12]. For this reason it is desirable to\nThis information can be stored in one bit of the prefix\nprogram the garbage collection routine for a list processing\nfield of a 7094 word, leaving one bit for the garbage collec-\nlanguage in the language itself. The routine, if it is to work\ntor's branch point flag. T h e scan shown in Figure 3 can\nin all cases, must use a fixed amount of temporary storage.\nagain be employed to mark the first registers of those ele-\nA recursive routine does not satisfy this condition because\nments attached to lists t h a t have not been discarded. Next,\nit requires a pushdown stack of indeterminate length on\ninstead of merely returning all non-negative registers to the\nwhich to store return addresses. We have seen t h a t the\nfree list, the sequential scan of storage, which is flow-\nWisp garbage collection is divided into two phases: t h a t\ncharted in Figure 4, must be used. This scan does not re-\nin which the list structure is traced and marked, and t h a t\nt u r n a negative register to the free l i s t ~ n o r any of the next\nin which the new free list is formed from the unmarked\nn - - 1 consecutive storage registers that make up the rest\nregisters. The second phase is severely machine-dependent,\nof the list element. Furthermore, this scan collects the\nbut the first can easily be written in a list language. T h e\nlargest block of consecutive discarded registers and forms\ntrace algorithm presented in Section 3 requires the addition\nthem into a single free list element.\nof several elementary operations to those normally found\nin Wise. These were:\nENTRY\n(1) set an element minus,\nSET I TO THE\n(2) set a branch point flag,\nBEGINNINGOFTHE\nLIST STORAGE\n(3) delete a branch point flag,\nAREA O~COUNT\n(\n(4) test the sign,\n(5) test the branch point flag, and\nYES\n(6) sequence from one list to the next.\n_ _ ~ C O U N\nMAKE IT\nYES B MAI\nOnce these functions have been defined in machine lan-\nguage, the Wisp compiler can translate the entire routine\nNO\n(which contains 35 WzsP statements).\nIPL.ACECUUNTINTO[\nADD CELL Z ANU\nTHE COUNTFIELD\nTHE NEXT ~-I\nI\nOF THECURRENT\nCELLS TO THE\n6.\nG a r b a g e C o l l e c t i o n i n a Variable I t e m L i s t\nFREE LIST\nCURRENTFREE\nELEMENT\nLIST\nEiEMENT\nVarious list processing systems have been proposed in\nwhich each list element consists of a number of consecutive\nCOUNT+~-.m,..\nregisters [5, 6, 9, 10]. T h a t is, if each element is to consist of\nCOUNT\nn registers and the element is stored at memory location M,\nthen the element is composed of the n consecutive registers\nM , M - t - l , . . . , M + n - - 1 . In some systems n is fixed for\nQ\nall list elements (n = 2 is a common choice), while in\nothers n m a y v a r y from one list element to the next.\nIf n, n > 1, is fixed, the problem of garbage collection is\nPLACE C O U N T I N T O ~ _ ~\nWE R:ACHE\nTHE COUNTFIELD NO\nsimilar to the case considered above where n = 1. T h e\nyES THE END\n~jgE\nOF THE CURRENT TO ZERO\nFREE LIST\nscan of Figure 3 is used to mark the first register of each\nELEMENT\nYES\nlist element minus. Whenever a negative register is found\nin the sequential scan of the store that follows, it and the\n1 I\nEXIT EXiT\nnext n - - 1 sequential registers are not returned to the free\nlist. If a positive register is found, it and the next n - 1 are     FzG. 4. Routine to reclaim variable-length items\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 505\n\n-------- Page Break --------\n\n7. G a r b a g e C o l l e c t i o n f o r O t h e r L i s t S t r u c t u r e s\nsaved address is used to restore the above Header field\nwhile the branch element address stored in that field is\nAs mentioned above, some list languages permit the\nused to resume scanning and marking the list on which the\nH E A D of a list element to contain the address of a full\nbranch element appeared.\nword of data. Since a data word may be a negative number,\nthis presents difficulties during garbage collection. To avoid\n8. C o n c l u s i o n\nthis difficulty, variable length list elements should be used\nIn this paper, various procedures for garbage collection\nto achieve full-word storage; this case then reduces to t h a t\nhave been presented. These procedures are useful for the\nof Section 6.\nlist processing systems and structures previously reported\nIn a threaded list system [10], sublists cannot be shared,\nin the literature. An algorithm which will trace any one-\nand garbage collection is particularly simple since the last\nway list has been presented, and its efficiency discussed. In\nelement always points to the head of a list or sublist. Dur-\nview of this routine's storage requirements and speed it\ning the forward scan it is not necessary to reverse the\nseems that the method of garbage collection is far more\npointers, nor is a reverse scan needed since both only serve\nefficient than the use of reference counters in one-way lists.\nto effect a return to the head of a (sub)fist. A flowchart of\nGarbage collection in other types of list structures appears\nthe first part of a garbage collection procedure for this\nto be implemented by even simpler procedures.\ntype of system is given in Figure 5.\nB y a slight extension of the elementary functions avail-\nT h e routine can also be employed, with a slight modifi-\nable to a list processing language, the garbage collection\ncation, to collect garbage in a two-way SLIP list [5, 6]. In\nprocedure m a y be described within the language in a non-\nsuch a list the first list element, called a Header, has two\nrecursive way, thus facilitating its transfer from one ma-\npointers. One points to the next list element while the\nchine to another. On the basis of these results, the use of\nsecond points to the last element. T h e last element points\ngarbage collection for reclaiming registers should always\nback to the Header. Garbage collection can be achieved by\nbe considered when implementing a list processing system.\nmodifying Figure 5 in the following manner.\n(1) When a list is first encountered, it is checked to see\nAcknowledgment. T h e authors gratefully acknowledge\nif it has already been traversed.\nthe cooperation of Professor M. V. Wilkes and his col-\n(2) When a branch is descended, the Header address\nleagues at the Cambridge University Mathematical Labo-\nfield which points to the last element is changed to point\nratory in transferring the Wrap system to the I B M 7094.\nback to the branch element. (This enables a return to be\nThis project was made possible by an allotment of time\nmade to the main list).\nfrom the Columbia University Computer Center.\n(3) In traversing the list, the address of the previous\nRECEIVED FEBRUARY, 1965; REVISEDMAY, 1967\nlist element marked is saved, When the pointer from the\nlast element back to the Header has been followed, this\nR E F E R E N C E S\nInformation Processing Language--W\n1. NEWELL, A. (ED.)\nENTRY\n2nd ed. Prentice Hall, Englewood N. J., 1964.\nManual,\nI\n2. McCARTHY, J. Recursive functions of symbolic expressions\nand their computation by machine, part I.\nComm. A C M 3\nSET I TO THE\nFIRST\n(April, 1960), 184.\nELEMENT\n3. GERLERNTEa,II., ET AL. A FORTRAN-compiled list-process-\nJ. A C M 7 (April 1960), 87.\ning language.\n4. COLLINS,G.E. A method for overlapping and erasure of lists.\nComm. A C M 8 (Dec. 1960), 655.\nComm. A C M 5\n5. WEIZENBAUM, J. Knotted list structures.\nSET I TO THE\n'E\n(Mar. 1962), 161.\nFIRST ELEMENT\nOF THE BRANCH\n6. WEIZENBAUM, J. Symmetric list processor.\nComm. A C M 6\n(Sept. 1963), 524.\n7. WILKES, M.V. An experiment with a self-compiling compiler\nYES\nfor a simple list-processing language.\nAnnual Review in\nAutomatic Programming, Vol. 4.\nPergamon Press, N.Y.\nNO\n1964, pp. 1-48.\n8. WILKES, M. V. Lists and why they are useful. Proc. ACM\n19th Nat. Conf., August 1964, ACM Publ. P-64, F1-1.\nNO OF THiS ;RANCH Jii\n9. COMFORT,W . T . Multiword list items.\nComm. A C M 7 (June\n1964), 357.\n10. EVANS,A., PERLIS, A. J., ANDVAN ZOEREN,It. Use of threaded\nlists in constructing a combined ALGOL and machine-like\nRES~: TO I\nComm. A C M 4 (Jan. 1961), 36.\nassembly processor.\n\"~ ELEMENT\n11. WAITE, W., AND SCrmRR, H. A note on the formation of a free\nBRANCH POINT\nlist.\nComm. A C M 8 (Aug. 1964), 478.\nMachineJndependent Computer Program-\n12. I-IALSTEAD,M. It.\nming. Spartan Books, Washington 1). C., 1962.\nEXIT\n13. McBETH, J. M. On the reference counter method.\nComm.\nA C M 6\n(Sept. 1963), 575.\nA scan for threaded lists\nFIG. 5.\n\n506 C o m m u n i c a t i o n s o f t h e A C M V o l u m e 10 / N u m b e r 8 / A u g u s t , 1967\n```\n\nGiven the paper in DOCS, generate a 140 character tweet that\ncaptures the paper idea and make it interesting.\n"
        }
      ]
    }
  ],
  "vars": {
    "spec": {
      "filename": "src/bztest/gc1.pdf.gpspec.md",
      "label": "context",
      "content": "# Specification\n                \n-   [gc1.pdf](./gc1.pdf)\n"
    },
    "files": [
      {
        "label": "gc1.pdf",
        "filename": "src/bztest/gc1.pdf",
        "content": "M . D. M c l L R O Y , Editor\n\n2. S t a t e m e n t o f t h e P r o b l e m a n d R e v i e w o f P a s t\nAn Efficient Machine-Independent\nS o l u t i o n s\nProcedure for Garbage Collection\nThe major problem which arises when attempting to re-\nclaim a part of a list structure is that of knowing which\nin Various List Structures\npart is no longer needed. This has received considerable\nattention in the literature [1-8] and three solutions have\nH. S C H O R R\nbeen proposed. The first, by Newell, Simon and Shaw [1],\nI B M Corp., Menlo Parle, California\nplaces the responsibility on the programmer. Their lan-\nAND\nguage (IPL-V) includes instructions which cause lists and\nW. M. WAITE\nlist structures to be erased, thereby returning their registers\nUniversity of Colorado,* Boulder, Colorado\nto the free list. This approach is unattractive because it\nrequires the programmer to keep track of the status of lists,\nsublists, etc. For example, part of a list m a y be shared with\nseveral other lists and might still be needed, while the re-\nmainder could be erased.\nA second solution for systems which use shared sublists,\noriginally due to Gerlernter et al. [3], extended by Collins\n[4], and used by Weizenbaum [5, 6], requires keeping a\nA method for returning registers to the free list is an essen-\ncount of the references made to a list and salvaging the\ntial part of any list processing system. In this paper, past\nregisters when the count reaches zero. In a one-way list\nsolutions of the recovery problem are reviewed and com-\nstructure it is impossible to locate the head of a list when a\npared. A new algorithm is presented which offers significant\nreference is made to some register along the list. Thus the\nadvantages of speed and storage utilization. The routine for\npart which starts from the referenced register must be\nimplementing this algorithm can be written in the list language\ntreated as a new list, and a new reference counter must be\nwith which it is to be used, thus insuring a degree of machine\nset up. T h e proliferation of reference counters, and\nindependence. Finally, the application of the algorithm to a\nthe large amount of bookkeeping involved, makes this\nnumber of different list structures appearing in the literature is\nmethod extremely cumbersome. In a two-way list [6] it is\nindicated.\nahvays possible to locate the head, and thus it is not neces-\n1. I n t r o d u c t i o n\nsary to set up a new reference counter. However, the head\nof the list must be found and the reference count increased\nOne of the most important features of a list language is\nby 1. Besides being time-consuming, this may prevent re-\nits ability to allocate storage dynamically during the run-\nturning part of a list to the free list. For example, in Figure\nning of the object program. This is accomplished by means\n1 there is no way of discarding the top part of list B if list\nof a list of\navailable space (or free list) which contains those\nA still needs the bottom part of B. Thus in practice this\nregisters not being used. Initially, the free list contains all\nstorage not occupied by the program [1, 2, 11], and regis-\npart of B has to be treated as a separate list and a new\nters are detached from it and formed into list structures\nreference counter is needed [5, 6]. T h e reference counter\nas the program is executed. T h e execution of the program\nmethod breaks down completely in the case of a circular\nmust usually be suspended when the free list is exhausted,\nlist (i.e., one in which the list is a sublist of itself). In this\nand the problem arises of reclaiming those parts of the list\nsituation the reference counter cannot be decreased to zero,\nstructure which are no longer needed (if any such exist). In\neven though the entire list m a y become inaccessible [13].\nthis paper a statement of the difficulties involved is fol-\nT h e third solution, which appears to be the most attrac-\nlowed by a brief review of the solutions which have been\ntive, was proposed by M c C a r t h y [2] and is considered in\nproposed. A new, machine-independent procedure and the\ndetail below. In this method, no reference counters are\nresults obtained using the 7094 version of this procedure\nkept and registers are not returned to the free list until the\nare presented. Finally, the application and modification of\nlatter has been exhausted. T h e n a procedure known as\nthis routine for a variety of list structures is discussed.\n\"garbage collection\" is initiated, which traces the entire\n* Department of Electrical Engineering\nlist structure, marking those registers which are attached\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 501\n\n-------- Page Break --------\n\nto some list. Registers no longer needed will not be attached\nwords making up such an element can be allowed to vary\nto any list and will thus remain unmarked. When all lists\nfrom element to element. These variable-length elements\nhave been traced, a routine is entered to form all unmarked\nwere proposed by Comfort [9], who also gave a solution to\nregisters into a new free list and erase the marks in all\nthe problem which is created of maintaining a generalized\nothers (in ease the garbage collector has to be used again\nfree list. In such a free list, an item of arbitrary length m a y\nlater).\nbe taken off, and to insure t h a t large elements are available\nSeveral difficulties arise in using and implementing a\nit is important to t r y to reconstruct the largest possible\ngarbage collection procedure.\nblocks of consecutive free registers when returning regis-\n(A) T h e basic problem is the tracing of the lists. In\nters to the free list. The problem of using a garbage collee-\ngeneral the lists will be branched and all branches must be\ntion procedure to achieve this is discussed below.\ntraced. Several methods have been suggested, but all re-\n3. A T e c h n i q u e for G a r b a g e C o l l e c t i o n i n a O n e -\nquire either a significant amount of additional storage (for\nW a y L i s t\nremembering the branch points encountered) or the re-\ntracing of large portions of the list structure m a n y times.    Solution of the basic problem (see Section 2A) of garbage\ncollection requires a routine t h a t is economical both in its\n(B) A second problem arises when the data consists of\nsigned numbers which are stored in a whole word. In  use of temporary storage and in the number of times it\ntraverses the list structure. In addition, of course, it must\nMcCarthy's method of garbage collection, the sign of each\nregister that is attached to a list is set to minus, while un-  be able to trace any possible list. A routine which uses a\nlimited amount of temporary storage for remembering the\nattached registers remain positive. The sign of an attached\nlocation of branch points cannot trace a list which has too\nregister is then reset to plus after the new free list has been\nm a n y such points, and a reeursive routine requires a push-\nformed. Clearly, this procedure, unless modified, will result\nin reversing the sign of any negative numbers. The modifi- down stack of indeterminate length on which to store re-\nturn addresses. Moreover, if a routine must traverse a par-\ncation proposed by M c C a r t h y is to reserve a block of stor-\ntieular list an indeterminate number of times it will fail\nage t h a t is to be used exclusively for whole-word data items\nwhen it encounters a circular list. In connection with an\n(full-word space). A second part of the store is then set aside\nimplementation of the Wisp language [7, S] for the I B M\nfor a bit table, to be used during garbage collection to re-\n7094, a method has been developed which uses two index\ncord which of the full words are still part of active list\nregisters and the accumulator for temporary storage and\nstructures. This modification is not completely satisfactory\nwhich traverses the list structure twice. This routine is\nsince (1) it violates the dynamic storage allocation princi-\ncapable of tracing any list structure (including circu-\nple of list processing languages, and (2) the storage used\nlar lists) which has any number of branch points.\nby the bit table and the additional part of the garbage\nIn the Wisp system as programmed for the 7094, the\ncollection program which utilizes it must be taken away\naddress field (TAIL) of a list element contains the loca-\nfrom the free list.\ntion of the next register on the list and is called a pointer.\n(C) Besides single full-word data items, multiple-word\nT h e decrement field (HEAD) contains either an atom [2]\nlist elements have been proposed, and the number of\nor the location of a branch of the list. A Wise list is shown\nin Figure 2(a). T h e prefix and tag fields are unused and\nhence are available for use by the garbage collector. T h e\nB\nalgorithm employed here is to move down a list ignoring\nsublists and reversing the pointers as one goes. This re-\nversal of pointers in a one-way list structure with shared\nsublists permits a return to be made to the head of a list\nduring garbage collection. During this first pass, the sign\nof each register is made negative. T h e end of the first pass\ni\nis reached when either (1) the end of the list is reached, or\n(2) a register on the list is encountered whose sign is minus\n(indicating that this part of the list is a sublist of some\ni t\nother list that has already been traversed). T h e result of\napplying this forward scan to the list D shown in Figure\n2(a) is given in Figure 2(b).\n1 I\nDuring the forward scan of the list, the contents of the\nH E A D of each list register are ignored. T h e reverse scan,\nwhich is entered when the forward scan is terminated,\nI i\nmoves back up the list restoring the original pointers. ID\naddition, it examines the H E A D of each register, checking\nto see if it contains a reference to a sublist. (In the 7094\nimplementation of WisP, any number larger than 2200 is a\npointer to a sublist, while any number less than this is an\nFiG. 1. Sharing a sublist in a two-way list structure\n\n502 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\n\n\n-------- Page Break --------\n\nnominal--68 words for the routine itself, in addition to the\n4. T h e R o u t i n e a n d its E f f i c i e n c y\ntwo index registers and accumulator.\nT h e routine itself is flowcharted in Figure 3. For con-\nFor purposes of comparison, a trace routine proposed by\nvenience in drawing the flowchart, the list elements are\nWilkes was coded for the 7094. I t required only two tempo-\nassumed to be numbered sequentially. Thus, list element\nrary storage locations, and occupied 35 words of memory.\nI + 1 follows list element I (i.e., list element I + 1 is pointed\nThis routine traversed a path from the head of a list to each\nto by the T A I L of list element I). T h e routine uses two in-\nterminal register separately. Thus much of the list was\ndex registers and the accumulator for temporary storage,\nscanned m a n y times, and the program would fail by enter-\nthough in general any three storage locations could be used.\ning a loop when attempting to trace a circular list. When\nOne contains the address of the previous list element ex-\nrun under the above conditions (5 binary trees of depth 12)\namined, the second the address of the element currently\nthe routine required 2.75 seconds for a complete trace.\nbeing examined and the third the address of the next ele-\nAs a final comparison, a routine which stored branch\nment on the list. This is necessary for the reversal of the\npoints was coded and run using the same list structure. T h e\npointers during the forward scan and their restoration\nprogram occupied 34 words, and an additional 48 words\nduring the reverse scan.\nwere allotted as a storage area for the branch points. Any\nIn order to evaluate the speed of the routine, a Wise\ngiven part of the list structure was only traversed once, so\nprogram was written which created five complete binary\nt h a t this routine could trace any list for which the number\ntrees of depth 12. T h e remaining registers were discarded\nof branch points it was required to store was less t h a n 49.\nand the garbage collector called. Thus it was forced to\nOnly .448 seconds were required to complete the trace of\ntrace a list structure containing over 20,000 registers, half\nthe test structure.\nof which were branch points. T h e elapsed time, according\nto the system clock, was 1.85 seconds. This list structure\nseems far more complex than any which would be en-\ncountered in practice, and therefore a normal garbage col-\nlection should take far less time. T h e space occupied is also\n\nENTRY\nYES\n\ni\n\nSET I TO I\ni\nFIRST CELL\nOF L ST\nEXIT\n\nQ\nYES\n\nRESTORE POINTER\nlNO\nRESTORE POINTER\nIN CAR OFI.\nOF CELL I\nCLEAR BRANCH\nI - ~ I\nPOINT FLAG.\nL\nI MAKE'TI\nMINUS\n\nF\nNO\n1\nI REVERSE POINTER\nOFCELLI\nW:l  ~~~iYESTO\nREVERSE POINTERI\nIN CAR OF I\nSET BRANCH\nPO NT FLAG\n\n1\nSET 2: TO\nYES\nFIRST CELL\nOF BRANCH\n\n(\nFIG. 3. T r a c e a l g o r i t h m f o r a o n e - w a y l i s t . F o r w a r d s c a n ; r e v e r s e s c a n\n\n504 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\nreturned. To see this, consider first the way in which the\nOn the basis of these results, it seems that the best gar-\nfree list is originally formed. If all of the unused storage\nbage collection procedure is to use the last routine with as\nconstitutes a consecutive block [11], then the free list can be\nmuch temporary storage as possible, and when this storage\nconstructed so t h a t a new free list element occurs at every\nis full to trace the remainder of the current branch using\nn t h memory address from the start of the block. Thus it\nthe algorithm given in Section 4. In this way one is able to\nsuffices to look at the every n t h location in the free storage\nrealize the most efficient collection for the amount of tem-\nspace; a positive register and the succeeding n - 1 registers\nporary memory available, and yet there is no possibility\ncan be returned to the free list.\nof failure for any structure. If, however, no temporary\nConsider next, garbage collection when n can vary from\nstorage area can be excluded from the free list or it is in-\none list element to the next. In this case, the H E A D of the\nconvenient to code two garbage collectors, then the al-\nfirst register does not ordinarily contain data, but rather\ngorithm of the previous section offers a reasonably efficient\ncontains the number n of registers that make up the ele-\nfail-safe solution.\nment. It is necessary then to distinguish between the fol-\n5. S y m b o l i c G a r b a g e C o l l e c t o r\nlowing items that m a y occupy the H E A D : (1) the number\nThe transfer of a programming system from one machine\nn, as above, of consecutive registers, for n > 1, and (2) the\nto another can be more easily achieved if the compiler and\ndata item itself (which m a y be a pointer to a sublist) if\nits utility routines are written in a higher level (nonma-\nn = l .\nchine) language [7, 12]. For this reason it is desirable to\nThis information can be stored in one bit of the prefix\nprogram the garbage collection routine for a list processing\nfield of a 7094 word, leaving one bit for the garbage collec-\nlanguage in the language itself. The routine, if it is to work\ntor's branch point flag. T h e scan shown in Figure 3 can\nin all cases, must use a fixed amount of temporary storage.\nagain be employed to mark the first registers of those ele-\nA recursive routine does not satisfy this condition because\nments attached to lists t h a t have not been discarded. Next,\nit requires a pushdown stack of indeterminate length on\ninstead of merely returning all non-negative registers to the\nwhich to store return addresses. We have seen t h a t the\nfree list, the sequential scan of storage, which is flow-\nWisp garbage collection is divided into two phases: t h a t\ncharted in Figure 4, must be used. This scan does not re-\nin which the list structure is traced and marked, and t h a t\nt u r n a negative register to the free l i s t ~ n o r any of the next\nin which the new free list is formed from the unmarked\nn - - 1 consecutive storage registers that make up the rest\nregisters. The second phase is severely machine-dependent,\nof the list element. Furthermore, this scan collects the\nbut the first can easily be written in a list language. T h e\nlargest block of consecutive discarded registers and forms\ntrace algorithm presented in Section 3 requires the addition\nthem into a single free list element.\nof several elementary operations to those normally found\nin Wise. These were:\nENTRY\n(1) set an element minus,\nSET I TO THE\n(2) set a branch point flag,\nBEGINNINGOFTHE\nLIST STORAGE\n(3) delete a branch point flag,\nAREA O~COUNT\n(\n(4) test the sign,\n(5) test the branch point flag, and\nYES\n(6) sequence from one list to the next.\n_ _ ~ C O U N\nMAKE IT\nYES B MAI\nOnce these functions have been defined in machine lan-\nguage, the Wisp compiler can translate the entire routine\nNO\n(which contains 35 WzsP statements).\nIPL.ACECUUNTINTO[\nADD CELL Z ANU\nTHE COUNTFIELD\nTHE NEXT ~-I\nI\nOF THECURRENT\nCELLS TO THE\n6.\nG a r b a g e C o l l e c t i o n i n a Variable I t e m L i s t\nFREE LIST\nCURRENTFREE\nELEMENT\nLIST\nEiEMENT\nVarious list processing systems have been proposed in\nwhich each list element consists of a number of consecutive\nCOUNT+~-.m,..\nregisters [5, 6, 9, 10]. T h a t is, if each element is to consist of\nCOUNT\nn registers and the element is stored at memory location M,\nthen the element is composed of the n consecutive registers\nM , M - t - l , . . . , M + n - - 1 . In some systems n is fixed for\nQ\nall list elements (n = 2 is a common choice), while in\nothers n m a y v a r y from one list element to the next.\nIf n, n > 1, is fixed, the problem of garbage collection is\nPLACE C O U N T I N T O ~ _ ~\nWE R:ACHE\nTHE COUNTFIELD NO\nsimilar to the case considered above where n = 1. T h e\nyES THE END\n~jgE\nOF THE CURRENT TO ZERO\nFREE LIST\nscan of Figure 3 is used to mark the first register of each\nELEMENT\nYES\nlist element minus. Whenever a negative register is found\nin the sequential scan of the store that follows, it and the\n1 I\nEXIT EXiT\nnext n - - 1 sequential registers are not returned to the free\nlist. If a positive register is found, it and the next n - 1 are     FzG. 4. Routine to reclaim variable-length items\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 505\n\n-------- Page Break --------\n\n7. G a r b a g e C o l l e c t i o n f o r O t h e r L i s t S t r u c t u r e s\nsaved address is used to restore the above Header field\nwhile the branch element address stored in that field is\nAs mentioned above, some list languages permit the\nused to resume scanning and marking the list on which the\nH E A D of a list element to contain the address of a full\nbranch element appeared.\nword of data. Since a data word may be a negative number,\nthis presents difficulties during garbage collection. To avoid\n8. C o n c l u s i o n\nthis difficulty, variable length list elements should be used\nIn this paper, various procedures for garbage collection\nto achieve full-word storage; this case then reduces to t h a t\nhave been presented. These procedures are useful for the\nof Section 6.\nlist processing systems and structures previously reported\nIn a threaded list system [10], sublists cannot be shared,\nin the literature. An algorithm which will trace any one-\nand garbage collection is particularly simple since the last\nway list has been presented, and its efficiency discussed. In\nelement always points to the head of a list or sublist. Dur-\nview of this routine's storage requirements and speed it\ning the forward scan it is not necessary to reverse the\nseems that the method of garbage collection is far more\npointers, nor is a reverse scan needed since both only serve\nefficient than the use of reference counters in one-way lists.\nto effect a return to the head of a (sub)fist. A flowchart of\nGarbage collection in other types of list structures appears\nthe first part of a garbage collection procedure for this\nto be implemented by even simpler procedures.\ntype of system is given in Figure 5.\nB y a slight extension of the elementary functions avail-\nT h e routine can also be employed, with a slight modifi-\nable to a list processing language, the garbage collection\ncation, to collect garbage in a two-way SLIP list [5, 6]. In\nprocedure m a y be described within the language in a non-\nsuch a list the first list element, called a Header, has two\nrecursive way, thus facilitating its transfer from one ma-\npointers. One points to the next list element while the\nchine to another. On the basis of these results, the use of\nsecond points to the last element. T h e last element points\ngarbage collection for reclaiming registers should always\nback to the Header. Garbage collection can be achieved by\nbe considered when implementing a list processing system.\nmodifying Figure 5 in the following manner.\n(1) When a list is first encountered, it is checked to see\nAcknowledgment. T h e authors gratefully acknowledge\nif it has already been traversed.\nthe cooperation of Professor M. V. Wilkes and his col-\n(2) When a branch is descended, the Header address\nleagues at the Cambridge University Mathematical Labo-\nfield which points to the last element is changed to point\nratory in transferring the Wrap system to the I B M 7094.\nback to the branch element. (This enables a return to be\nThis project was made possible by an allotment of time\nmade to the main list).\nfrom the Columbia University Computer Center.\n(3) In traversing the list, the address of the previous\nRECEIVED FEBRUARY, 1965; REVISEDMAY, 1967\nlist element marked is saved, When the pointer from the\nlast element back to the Header has been followed, this\nR E F E R E N C E S\nInformation Processing Language--W\n1. NEWELL, A. (ED.)\nENTRY\n2nd ed. Prentice Hall, Englewood N. J., 1964.\nManual,\nI\n2. McCARTHY, J. Recursive functions of symbolic expressions\nand their computation by machine, part I.\nComm. A C M 3\nSET I TO THE\nFIRST\n(April, 1960), 184.\nELEMENT\n3. GERLERNTEa,II., ET AL. A FORTRAN-compiled list-process-\nJ. A C M 7 (April 1960), 87.\ning language.\n4. COLLINS,G.E. A method for overlapping and erasure of lists.\nComm. A C M 8 (Dec. 1960), 655.\nComm. A C M 5\n5. WEIZENBAUM, J. Knotted list structures.\nSET I TO THE\n'E\n(Mar. 1962), 161.\nFIRST ELEMENT\nOF THE BRANCH\n6. WEIZENBAUM, J. Symmetric list processor.\nComm. A C M 6\n(Sept. 1963), 524.\n7. WILKES, M.V. An experiment with a self-compiling compiler\nYES\nfor a simple list-processing language.\nAnnual Review in\nAutomatic Programming, Vol. 4.\nPergamon Press, N.Y.\nNO\n1964, pp. 1-48.\n8. WILKES, M. V. Lists and why they are useful. Proc. ACM\n19th Nat. Conf., August 1964, ACM Publ. P-64, F1-1.\nNO OF THiS ;RANCH Jii\n9. COMFORT,W . T . Multiword list items.\nComm. A C M 7 (June\n1964), 357.\n10. EVANS,A., PERLIS, A. J., ANDVAN ZOEREN,It. Use of threaded\nlists in constructing a combined ALGOL and machine-like\nRES~: TO I\nComm. A C M 4 (Jan. 1961), 36.\nassembly processor.\n\"~ ELEMENT\n11. WAITE, W., AND SCrmRR, H. A note on the formation of a free\nBRANCH POINT\nlist.\nComm. A C M 8 (Aug. 1964), 478.\nMachineJndependent Computer Program-\n12. I-IALSTEAD,M. It.\nming. Spartan Books, Washington 1). C., 1962.\nEXIT\n13. McBETH, J. M. On the reference counter method.\nComm.\nA C M 6\n(Sept. 1963), 575.\nA scan for threaded lists\nFIG. 5.\n\n506 C o m m u n i c a t i o n s o f t h e A C M V o l u m e 10 / N u m b e r 8 / A u g u s t , 1967"
      }
    ],
    "fence": "```",
    "markdownFence": "`````",
    "vars": {},
    "template": {
      "id": "pdf-to-tweet",
      "title": "generate a tweet from a pdf file"
    },
    "secrets": {}
  },
  "edits": [
    {
      "label": "Create src/bztest/gc1.pdf.pdf-to-tweet.json",
      "filename": "src/bztest/gc1.pdf.pdf-to-tweet.json",
      "type": "createfile",
      "text": "\"Discover the art of efficient garbage collection in list structures without the hassle of manual tracking or cumbersome counters! #ComputerScience #Innovation\"",
      "overwrite": true
    }
  ],
  "annotations": [],
  "changelogs": [],
  "fileEdits": {
    "src/bztest/gc1.pdf.pdf-to-tweet.json": {
      "before": null,
      "after": "\"Discover the art of efficient garbage collection in list structures without the hassle of manual tracking or cumbersome counters! #ComputerScience #Innovation\""
    }
  },
  "trace": "## pdf-to-tweet\n\n\n\n<details id=\"-spec\" class=\"genaiscript\">\n<summary>\n spec\n</summary>\n\n\n```markdown\n# Specification\n                \n-   [gc1.pdf](./gc1.pdf)\n```\n\n</details>\n\n\n\n<details id=\"-script\" class=\"genaiscript\">\n<summary>\n script\n</summary>\n\n\n\n<details id=\"-prompt\" class=\"genaiscript\">\n<summary>\n prompt\n</summary>\n\n\n\n<details id=\"-script-source\" class=\"genaiscript\">\n<summary>\n script source\n</summary>\n\n\n```js\nscript({\n    title: \"generate a tweet from a pdf file\"\n})\n\ndef(\"DOCS\", env.files) // contains some pdfs\n\n$`Given the paper in DOCS, generate a 140 character tweet that\ncaptures the paper idea and make it interesting.`\n```\n\n</details>\n\n-   model: gpt-4\n-   temperature: 0.2\n-   tokens: 6014\n\n````markdown\nDOCS:\n```pdf file=\"src/bztest/gc1.pdf\"\nM . D. M c l L R O Y , Editor\n\n2. S t a t e m e n t o f t h e P r o b l e m a n d R e v i e w o f P a s t\nAn Efficient Machine-Independent\nS o l u t i o n s\nProcedure for Garbage Collection\nThe major problem which arises when attempting to re-\nclaim a part of a list structure is that of knowing which\nin Various List Structures\npart is no longer needed. This has received considerable\nattention in the literature [1-8] and three solutions have\nH. S C H O R R\nbeen proposed. The first, by Newell, Simon and Shaw [1],\nI B M Corp., Menlo Parle, California\nplaces the responsibility on the programmer. Their lan-\nAND\nguage (IPL-V) includes instructions which cause lists and\nW. M. WAITE\nlist structures to be erased, thereby returning their registers\nUniversity of Colorado,* Boulder, Colorado\nto the free list. This approach is unattractive because it\nrequires the programmer to keep track of the status of lists,\nsublists, etc. For example, part of a list m a y be shared with\nseveral other lists and might still be needed, while the re-\nmainder could be erased.\nA second solution for systems which use shared sublists,\noriginally due to Gerlernter et al. [3], extended by Collins\n[4], and used by Weizenbaum [5, 6], requires keeping a\nA method for returning registers to the free list is an essen-\ncount of the references made to a list and salvaging the\ntial part of any list processing system. In this paper, past\nregisters when the count reaches zero. In a one-way list\nsolutions of the recovery problem are reviewed and com-\nstructure it is impossible to locate the head of a list when a\npared. A new algorithm is presented which offers significant\nreference is made to some register along the list. Thus the\nadvantages of speed and storage utilization. The routine for\npart which starts from the referenced register must be\nimplementing this algorithm can be written in the list language\ntreated as a new list, and a new reference counter must be\nwith which it is to be used, thus insuring a degree of machine\nset up. T h e proliferation of reference counters, and\nindependence. Finally, the application of the algorithm to a\nthe large amount of bookkeeping involved, makes this\nnumber of different list structures appearing in the literature is\nmethod extremely cumbersome. In a two-way list [6] it is\nindicated.\nahvays possible to locate the head, and thus it is not neces-\n1. I n t r o d u c t i o n\nsary to set up a new reference counter. However, the head\nof the list must be found and the reference count increased\nOne of the most important features of a list language is\nby 1. Besides being time-consuming, this may prevent re-\nits ability to allocate storage dynamically during the run-\nturning part of a list to the free list. For example, in Figure\nning of the object program. This is accomplished by means\n1 there is no way of discarding the top part of list B if list\nof a list of\navailable space (or free list) which contains those\nA still needs the bottom part of B. Thus in practice this\nregisters not being used. Initially, the free list contains all\nstorage not occupied by the program [1, 2, 11], and regis-\npart of B has to be treated as a separate list and a new\nters are detached from it and formed into list structures\nreference counter is needed [5, 6]. T h e reference counter\nas the program is executed. T h e execution of the program\nmethod breaks down completely in the case of a circular\nmust usually be suspended when the free list is exhausted,\nlist (i.e., one in which the list is a sublist of itself). In this\nand the problem arises of reclaiming those parts of the list\nsituation the reference counter cannot be decreased to zero,\nstructure which are no longer needed (if any such exist). In\neven though the entire list m a y become inaccessible [13].\nthis paper a statement of the difficulties involved is fol-\nT h e third solution, which appears to be the most attrac-\nlowed by a brief review of the solutions which have been\ntive, was proposed by M c C a r t h y [2] and is considered in\nproposed. A new, machine-independent procedure and the\ndetail below. In this method, no reference counters are\nresults obtained using the 7094 version of this procedure\nkept and registers are not returned to the free list until the\nare presented. Finally, the application and modification of\nlatter has been exhausted. T h e n a procedure known as\nthis routine for a variety of list structures is discussed.\n\"garbage collection\" is initiated, which traces the entire\n* Department of Electrical Engineering\nlist structure, marking those registers which are attached\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 501\n\n-------- Page Break --------\n\nto some list. Registers no longer needed will not be attached\nwords making up such an element can be allowed to vary\nto any list and will thus remain unmarked. When all lists\nfrom element to element. These variable-length elements\nhave been traced, a routine is entered to form all unmarked\nwere proposed by Comfort [9], who also gave a solution to\nregisters into a new free list and erase the marks in all\nthe problem which is created of maintaining a generalized\nothers (in ease the garbage collector has to be used again\nfree list. In such a free list, an item of arbitrary length m a y\nlater).\nbe taken off, and to insure t h a t large elements are available\nSeveral difficulties arise in using and implementing a\nit is important to t r y to reconstruct the largest possible\ngarbage collection procedure.\nblocks of consecutive free registers when returning regis-\n(A) T h e basic problem is the tracing of the lists. In\nters to the free list. The problem of using a garbage collee-\ngeneral the lists will be branched and all branches must be\ntion procedure to achieve this is discussed below.\ntraced. Several methods have been suggested, but all re-\n3. A T e c h n i q u e for G a r b a g e C o l l e c t i o n i n a O n e -\nquire either a significant amount of additional storage (for\nW a y L i s t\nremembering the branch points encountered) or the re-\ntracing of large portions of the list structure m a n y times.    Solution of the basic problem (see Section 2A) of garbage\ncollection requires a routine t h a t is economical both in its\n(B) A second problem arises when the data consists of\nsigned numbers which are stored in a whole word. In  use of temporary storage and in the number of times it\ntraverses the list structure. In addition, of course, it must\nMcCarthy's method of garbage collection, the sign of each\nregister that is attached to a list is set to minus, while un-  be able to trace any possible list. A routine which uses a\nlimited amount of temporary storage for remembering the\nattached registers remain positive. The sign of an attached\nlocation of branch points cannot trace a list which has too\nregister is then reset to plus after the new free list has been\nm a n y such points, and a reeursive routine requires a push-\nformed. Clearly, this procedure, unless modified, will result\nin reversing the sign of any negative numbers. The modifi- down stack of indeterminate length on which to store re-\nturn addresses. Moreover, if a routine must traverse a par-\ncation proposed by M c C a r t h y is to reserve a block of stor-\ntieular list an indeterminate number of times it will fail\nage t h a t is to be used exclusively for whole-word data items\nwhen it encounters a circular list. In connection with an\n(full-word space). A second part of the store is then set aside\nimplementation of the Wisp language [7, S] for the I B M\nfor a bit table, to be used during garbage collection to re-\n7094, a method has been developed which uses two index\ncord which of the full words are still part of active list\nregisters and the accumulator for temporary storage and\nstructures. This modification is not completely satisfactory\nwhich traverses the list structure twice. This routine is\nsince (1) it violates the dynamic storage allocation princi-\ncapable of tracing any list structure (including circu-\nple of list processing languages, and (2) the storage used\nlar lists) which has any number of branch points.\nby the bit table and the additional part of the garbage\nIn the Wisp system as programmed for the 7094, the\ncollection program which utilizes it must be taken away\naddress field (TAIL) of a list element contains the loca-\nfrom the free list.\ntion of the next register on the list and is called a pointer.\n(C) Besides single full-word data items, multiple-word\nT h e decrement field (HEAD) contains either an atom [2]\nlist elements have been proposed, and the number of\nor the location of a branch of the list. A Wise list is shown\nin Figure 2(a). T h e prefix and tag fields are unused and\nhence are available for use by the garbage collector. T h e\nB\nalgorithm employed here is to move down a list ignoring\nsublists and reversing the pointers as one goes. This re-\nversal of pointers in a one-way list structure with shared\nsublists permits a return to be made to the head of a list\nduring garbage collection. During this first pass, the sign\nof each register is made negative. T h e end of the first pass\ni\nis reached when either (1) the end of the list is reached, or\n(2) a register on the list is encountered whose sign is minus\n(indicating that this part of the list is a sublist of some\ni t\nother list that has already been traversed). T h e result of\napplying this forward scan to the list D shown in Figure\n2(a) is given in Figure 2(b).\n1 I\nDuring the forward scan of the list, the contents of the\nH E A D of each list register are ignored. T h e reverse scan,\nwhich is entered when the forward scan is terminated,\nI i\nmoves back up the list restoring the original pointers. ID\naddition, it examines the H E A D of each register, checking\nto see if it contains a reference to a sublist. (In the 7094\nimplementation of WisP, any number larger than 2200 is a\npointer to a sublist, while any number less than this is an\nFiG. 1. Sharing a sublist in a two-way list structure\n\n502 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\n\n\n-------- Page Break --------\n\nnominal--68 words for the routine itself, in addition to the\n4. T h e R o u t i n e a n d its E f f i c i e n c y\ntwo index registers and accumulator.\nT h e routine itself is flowcharted in Figure 3. For con-\nFor purposes of comparison, a trace routine proposed by\nvenience in drawing the flowchart, the list elements are\nWilkes was coded for the 7094. I t required only two tempo-\nassumed to be numbered sequentially. Thus, list element\nrary storage locations, and occupied 35 words of memory.\nI + 1 follows list element I (i.e., list element I + 1 is pointed\nThis routine traversed a path from the head of a list to each\nto by the T A I L of list element I). T h e routine uses two in-\nterminal register separately. Thus much of the list was\ndex registers and the accumulator for temporary storage,\nscanned m a n y times, and the program would fail by enter-\nthough in general any three storage locations could be used.\ning a loop when attempting to trace a circular list. When\nOne contains the address of the previous list element ex-\nrun under the above conditions (5 binary trees of depth 12)\namined, the second the address of the element currently\nthe routine required 2.75 seconds for a complete trace.\nbeing examined and the third the address of the next ele-\nAs a final comparison, a routine which stored branch\nment on the list. This is necessary for the reversal of the\npoints was coded and run using the same list structure. T h e\npointers during the forward scan and their restoration\nprogram occupied 34 words, and an additional 48 words\nduring the reverse scan.\nwere allotted as a storage area for the branch points. Any\nIn order to evaluate the speed of the routine, a Wise\ngiven part of the list structure was only traversed once, so\nprogram was written which created five complete binary\nt h a t this routine could trace any list for which the number\ntrees of depth 12. T h e remaining registers were discarded\nof branch points it was required to store was less t h a n 49.\nand the garbage collector called. Thus it was forced to\nOnly .448 seconds were required to complete the trace of\ntrace a list structure containing over 20,000 registers, half\nthe test structure.\nof which were branch points. T h e elapsed time, according\nto the system clock, was 1.85 seconds. This list structure\nseems far more complex than any which would be en-\ncountered in practice, and therefore a normal garbage col-\nlection should take far less time. T h e space occupied is also\n\nENTRY\nYES\n\ni\n\nSET I TO I\ni\nFIRST CELL\nOF L ST\nEXIT\n\nQ\nYES\n\nRESTORE POINTER\nlNO\nRESTORE POINTER\nIN CAR OFI.\nOF CELL I\nCLEAR BRANCH\nI - ~ I\nPOINT FLAG.\nL\nI MAKE'TI\nMINUS\n\nF\nNO\n1\nI REVERSE POINTER\nOFCELLI\nW:l  ~~~iYESTO\nREVERSE POINTERI\nIN CAR OF I\nSET BRANCH\nPO NT FLAG\n\n1\nSET 2: TO\nYES\nFIRST CELL\nOF BRANCH\n\n(\nFIG. 3. T r a c e a l g o r i t h m f o r a o n e - w a y l i s t . F o r w a r d s c a n ; r e v e r s e s c a n\n\n504 Communications of the ACM Volume 10 / Number 8 / August, 1967\n\n-------- Page Break --------\n\nreturned. To see this, consider first the way in which the\nOn the basis of these results, it seems that the best gar-\nfree list is originally formed. If all of the unused storage\nbage collection procedure is to use the last routine with as\nconstitutes a consecutive block [11], then the free list can be\nmuch temporary storage as possible, and when this storage\nconstructed so t h a t a new free list element occurs at every\nis full to trace the remainder of the current branch using\nn t h memory address from the start of the block. Thus it\nthe algorithm given in Section 4. In this way one is able to\nsuffices to look at the every n t h location in the free storage\nrealize the most efficient collection for the amount of tem-\nspace; a positive register and the succeeding n - 1 registers\nporary memory available, and yet there is no possibility\ncan be returned to the free list.\nof failure for any structure. If, however, no temporary\nConsider next, garbage collection when n can vary from\nstorage area can be excluded from the free list or it is in-\none list element to the next. In this case, the H E A D of the\nconvenient to code two garbage collectors, then the al-\nfirst register does not ordinarily contain data, but rather\ngorithm of the previous section offers a reasonably efficient\ncontains the number n of registers that make up the ele-\nfail-safe solution.\nment. It is necessary then to distinguish between the fol-\n5. S y m b o l i c G a r b a g e C o l l e c t o r\nlowing items that m a y occupy the H E A D : (1) the number\nThe transfer of a programming system from one machine\nn, as above, of consecutive registers, for n > 1, and (2) the\nto another can be more easily achieved if the compiler and\ndata item itself (which m a y be a pointer to a sublist) if\nits utility routines are written in a higher level (nonma-\nn = l .\nchine) language [7, 12]. For this reason it is desirable to\nThis information can be stored in one bit of the prefix\nprogram the garbage collection routine for a list processing\nfield of a 7094 word, leaving one bit for the garbage collec-\nlanguage in the language itself. The routine, if it is to work\ntor's branch point flag. T h e scan shown in Figure 3 can\nin all cases, must use a fixed amount of temporary storage.\nagain be employed to mark the first registers of those ele-\nA recursive routine does not satisfy this condition because\nments attached to lists t h a t have not been discarded. Next,\nit requires a pushdown stack of indeterminate length on\ninstead of merely returning all non-negative registers to the\nwhich to store return addresses. We have seen t h a t the\nfree list, the sequential scan of storage, which is flow-\nWisp garbage collection is divided into two phases: t h a t\ncharted in Figure 4, must be used. This scan does not re-\nin which the list structure is traced and marked, and t h a t\nt u r n a negative register to the free l i s t ~ n o r any of the next\nin which the new free list is formed from the unmarked\nn - - 1 consecutive storage registers that make up the rest\nregisters. The second phase is severely machine-dependent,\nof the list element. Furthermore, this scan collects the\nbut the first can easily be written in a list language. T h e\nlargest block of consecutive discarded registers and forms\ntrace algorithm presented in Section 3 requires the addition\nthem into a single free list element.\nof several elementary operations to those normally found\nin Wise. These were:\nENTRY\n(1) set an element minus,\nSET I TO THE\n(2) set a branch point flag,\nBEGINNINGOFTHE\nLIST STORAGE\n(3) delete a branch point flag,\nAREA O~COUNT\n(\n(4) test the sign,\n(5) test the branch point flag, and\nYES\n(6) sequence from one list to the next.\n_ _ ~ C O U N\nMAKE IT\nYES B MAI\nOnce these functions have been defined in machine lan-\nguage, the Wisp compiler can translate the entire routine\nNO\n(which contains 35 WzsP statements).\nIPL.ACECUUNTINTO[\nADD CELL Z ANU\nTHE COUNTFIELD\nTHE NEXT ~-I\nI\nOF THECURRENT\nCELLS TO THE\n6.\nG a r b a g e C o l l e c t i o n i n a Variable I t e m L i s t\nFREE LIST\nCURRENTFREE\nELEMENT\nLIST\nEiEMENT\nVarious list processing systems have been proposed in\nwhich each list element consists of a number of consecutive\nCOUNT+~-.m,..\nregisters [5, 6, 9, 10]. T h a t is, if each element is to consist of\nCOUNT\nn registers and the element is stored at memory location M,\nthen the element is composed of the n consecutive registers\nM , M - t - l , . . . , M + n - - 1 . In some systems n is fixed for\nQ\nall list elements (n = 2 is a common choice), while in\nothers n m a y v a r y from one list element to the next.\nIf n, n > 1, is fixed, the problem of garbage collection is\nPLACE C O U N T I N T O ~ _ ~\nWE R:ACHE\nTHE COUNTFIELD NO\nsimilar to the case considered above where n = 1. T h e\nyES THE END\n~jgE\nOF THE CURRENT TO ZERO\nFREE LIST\nscan of Figure 3 is used to mark the first register of each\nELEMENT\nYES\nlist element minus. Whenever a negative register is found\nin the sequential scan of the store that follows, it and the\n1 I\nEXIT EXiT\nnext n - - 1 sequential registers are not returned to the free\nlist. If a positive register is found, it and the next n - 1 are     FzG. 4. Routine to reclaim variable-length items\n\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 505\n\n-------- Page Break --------\n\n7. G a r b a g e C o l l e c t i o n f o r O t h e r L i s t S t r u c t u r e s\nsaved address is used to restore the above Header field\nwhile the branch element address stored in that field is\nAs mentioned above, some list languages permit the\nused to resume scanning and marking the list on which the\nH E A D of a list element to contain the address of a full\nbranch element appeared.\nword of data. Since a data word may be a negative number,\nthis presents difficulties during garbage collection. To avoid\n8. C o n c l u s i o n\nthis difficulty, variable length list elements should be used\nIn this paper, various procedures for garbage collection\nto achieve full-word storage; this case then reduces to t h a t\nhave been presented. These procedures are useful for the\nof Section 6.\nlist processing systems and structures previously reported\nIn a threaded list system [10], sublists cannot be shared,\nin the literature. An algorithm which will trace any one-\nand garbage collection is particularly simple since the last\nway list has been presented, and its efficiency discussed. In\nelement always points to the head of a list or sublist. Dur-\nview of this routine's storage requirements and speed it\ning the forward scan it is not necessary to reverse the\nseems that the method of garbage collection is far more\npointers, nor is a reverse scan needed since both only serve\nefficient than the use of reference counters in one-way lists.\nto effect a return to the head of a (sub)fist. A flowchart of\nGarbage collection in other types of list structures appears\nthe first part of a garbage collection procedure for this\nto be implemented by even simpler procedures.\ntype of system is given in Figure 5.\nB y a slight extension of the elementary functions avail-\nT h e routine can also be employed, with a slight modifi-\nable to a list processing language, the garbage collection\ncation, to collect garbage in a two-way SLIP list [5, 6]. In\nprocedure m a y be described within the language in a non-\nsuch a list the first list element, called a Header, has two\nrecursive way, thus facilitating its transfer from one ma-\npointers. One points to the next list element while the\nchine to another. On the basis of these results, the use of\nsecond points to the last element. T h e last element points\ngarbage collection for reclaiming registers should always\nback to the Header. Garbage collection can be achieved by\nbe considered when implementing a list processing system.\nmodifying Figure 5 in the following manner.\n(1) When a list is first encountered, it is checked to see\nAcknowledgment. T h e authors gratefully acknowledge\nif it has already been traversed.\nthe cooperation of Professor M. V. Wilkes and his col-\n(2) When a branch is descended, the Header address\nleagues at the Cambridge University Mathematical Labo-\nfield which points to the last element is changed to point\nratory in transferring the Wrap system to the I B M 7094.\nback to the branch element. (This enables a return to be\nThis project was made possible by an allotment of time\nmade to the main list).\nfrom the Columbia University Computer Center.\n(3) In traversing the list, the address of the previous\nRECEIVED FEBRUARY, 1965; REVISEDMAY, 1967\nlist element marked is saved, When the pointer from the\nlast element back to the Header has been followed, this\nR E F E R E N C E S\nInformation Processing Language--W\n1. NEWELL, A. (ED.)\nENTRY\n2nd ed. Prentice Hall, Englewood N. J., 1964.\nManual,\nI\n2. McCARTHY, J. Recursive functions of symbolic expressions\nand their computation by machine, part I.\nComm. A C M 3\nSET I TO THE\nFIRST\n(April, 1960), 184.\nELEMENT\n3. GERLERNTEa,II., ET AL. A FORTRAN-compiled list-process-\nJ. A C M 7 (April 1960), 87.\ning language.\n4. COLLINS,G.E. A method for overlapping and erasure of lists.\nComm. A C M 8 (Dec. 1960), 655.\nComm. A C M 5\n5. WEIZENBAUM, J. Knotted list structures.\nSET I TO THE\n'E\n(Mar. 1962), 161.\nFIRST ELEMENT\nOF THE BRANCH\n6. WEIZENBAUM, J. Symmetric list processor.\nComm. A C M 6\n(Sept. 1963), 524.\n7. WILKES, M.V. An experiment with a self-compiling compiler\nYES\nfor a simple list-processing language.\nAnnual Review in\nAutomatic Programming, Vol. 4.\nPergamon Press, N.Y.\nNO\n1964, pp. 1-48.\n8. WILKES, M. V. Lists and why they are useful. Proc. ACM\n19th Nat. Conf., August 1964, ACM Publ. P-64, F1-1.\nNO OF THiS ;RANCH Jii\n9. COMFORT,W . T . Multiword list items.\nComm. A C M 7 (June\n1964), 357.\n10. EVANS,A., PERLIS, A. J., ANDVAN ZOEREN,It. Use of threaded\nlists in constructing a combined ALGOL and machine-like\nRES~: TO I\nComm. A C M 4 (Jan. 1961), 36.\nassembly processor.\n\"~ ELEMENT\n11. WAITE, W., AND SCrmRR, H. A note on the formation of a free\nBRANCH POINT\nlist.\nComm. A C M 8 (Aug. 1964), 478.\nMachineJndependent Computer Program-\n12. I-IALSTEAD,M. It.\nming. Spartan Books, Washington 1). C., 1962.\nEXIT\n13. McBETH, J. M. On the reference counter method.\nComm.\nA C M 6\n(Sept. 1963), 575.\nA scan for threaded lists\nFIG. 5.\n\n506 C o m m u n i c a t i o n s o f t h e A C M V o l u m e 10 / N u m b e r 8 / A u g u s t , 1967\n```\n\nGiven the paper in DOCS, generate a 140 character tweet that\ncaptures the paper idea and make it interesting.\n````\n\n</details>\n\n\n\n<details id=\"-system\" class=\"genaiscript\">\n<summary>\n system\n</summary>\n\n-   tokens: 8\n\n```markdown\nYou are concise. Answer in markdown.\n```\n\n\n<details id=\"js\" class=\"genaiscript\">\n<summary>\njs\n</summary>\n\n\n```js\nsystem({ title: \"Markdown system prompt\" })\n$`You are concise. Answer in markdown.`\n```\n\n</details>\n\n\n</details>\n\n\n\n<details id=\"-system.explanations\" class=\"genaiscript\">\n<summary>\n system.explanations\n</summary>\n\n-   tokens: 9\n\n```markdown\nWhen explaining answers, take a deep breath.\n```\n\n\n<details id=\"js\" class=\"genaiscript\">\n<summary>\njs\n</summary>\n\n\n```js\nsystem({ title: \"Explain your answers\" })\n$`When explaining answers, take a deep breath.`\n```\n\n</details>\n\n\n</details>\n\n\n\n<details id=\"-system.files\" class=\"genaiscript\">\n<summary>\n system.files\n</summary>\n\n###  \n\n\n```yaml\nerrno: -2\ncode: ENOENT\nsyscall: open\npath: \"\"\n```\n###  \n\n\n```yaml\nerrno: -2\ncode: ENOENT\nsyscall: open\npath: \"\"\n```\n###  \n\n\n```yaml\nerrno: -2\ncode: ENOENT\nsyscall: open\npath: \"\"\n```\n-   tokens: 79\n\n``````markdown\n## Files\n\nWhen generating or updating files you will use the following syntax:\nMake sure to use precisely ``` to guard file code sections.\nMake sure to use precisely ````` to guard file markdown sections.\nUse full path of filename in code section header.\nIf a file does not have changes, do not regenerate.\nDo NOT emit line numbers in file.\nCSV files are inlined as markdown tables.\n``````\n\n\n<details id=\"js\" class=\"genaiscript\">\n<summary>\njs\n</summary>\n\n\n```js\nsystem({\n    title: \"File generation\",\n    description: \"Teaches the file format supported by GenAIScripts\",\n})\n\nconst folder =\n    env.vars[\"outputFolder\"] || \".\"\n$`## Files\n\nWhen generating or updating files you will use the following syntax:`\n\ndef(\n    `File ${folder}/file1.ts`,\n    `What goes in\\n${folder}/file1.ts.`,\n    { language: \"typescript\" }\n)\ndef(\n    `File ${folder}/file1.py`,\n    `What goes in\\n${folder}/file1.py.`,\n    { language: \"python\" }\n)\ndef(\n    `File /path_to_file/file2.md`,\n    `What goes in\\n/path_to_file/file2.md.`,\n    { language: \"markdown\" }\n)\n\n$`Make sure to use precisely ${env.fence} to guard file code sections.`\n$`Make sure to use precisely ${env.markdownFence} to guard file markdown sections.`\n$`Use full path of filename in code section header.`\nif (folder !== \".\") $`When generating new files, place files in folder \"${folder}\".`\n$`If a file does not have changes, do not regenerate.`\n$`Do NOT emit line numbers in file.`\n$`CSV files are inlined as markdown tables.`\n```\n\n</details>\n\n\n</details>\n\n\n</details>\n\n\n\n<details id=\"-llm-request-(2-messages)\" class=\"genaiscript\">\n<summary>\n llm request (2 messages)\n</summary>\n\n-   tokens: 6124\n-   temperature: 0.2\n-   api type: azure\n-   model: gpt-4\n-   url: [https://tnrllmproxy.azurewebsites.net/openai/deployments/gpt-4/chat/completions?api-version=2023-09-01-preview](https://tnrllmproxy.azurewebsites.net/openai/deployments/gpt-4/chat/completions?api-version=2023-09-01-preview)\n\n\n<details id=\"-messages\" class=\"genaiscript\">\n<summary>\n messages\n</summary>\n\n\n``````json\n{\n  \"temperature\": 0.2,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"---\\nYou are concise. Answer in markdown.\\n\\n---\\nWhen explaining answers, take a deep breath.\\n\\n---\\n## Files\\n\\nWhen generating or updating files you will use the following syntax:\\nMake sure to use precisely ``` to guard file code sections.\\nMake sure to use precisely ````` to guard file markdown sections.\\nUse full path of filename in code section header.\\nIf a file does not have changes, do not regenerate.\\nDo NOT emit line numbers in file.\\nCSV files are inlined as markdown tables.\\n\\n\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"DOCS:\\n```pdf file=\\\"src/bztest/gc1.pdf\\\"\\nM . D. M c l L R O Y , Editor\\n\\n2. S t a t e m e n t o f t h e P r o b l e m a n d R e v i e w o f P a s t\\nAn Efficient Machine-Independent\\nS o l u t i o n s\\nProcedure for Garbage Collection\\nThe major problem which arises when attempting to re-\\nclaim a part of a list structure is that of knowing which\\nin Various List Structures\\npart is no longer needed. This has received considerable\\nattention in the literature [1-8] and three solutions have\\nH. S C H O R R\\nbeen proposed. The first, by Newell, Simon and Shaw [1],\\nI B M Corp., Menlo Parle, California\\nplaces the responsibility on the programmer. Their lan-\\nAND\\nguage (IPL-V) includes instructions which cause lists and\\nW. M. WAITE\\nlist structures to be erased, thereby returning their registers\\nUniversity of Colorado,* Boulder, Colorado\\nto the free list. This approach is unattractive because it\\nrequires the programmer to keep track of the status of lists,\\nsublists, etc. For example, part of a list m a y be shared with\\nseveral other lists and might still be needed, while the re-\\nmainder could be erased.\\nA second solution for systems which use shared sublists,\\noriginally due to Gerlernter et al. [3], extended by Collins\\n[4], and used by Weizenbaum [5, 6], requires keeping a\\nA method for returning registers to the free list is an essen-\\ncount of the references made to a list and salvaging the\\ntial part of any list processing system. In this paper, past\\nregisters when the count reaches zero. In a one-way list\\nsolutions of the recovery problem are reviewed and com-\\nstructure it is impossible to locate the head of a list when a\\npared. A new algorithm is presented which offers significant\\nreference is made to some register along the list. Thus the\\nadvantages of speed and storage utilization. The routine for\\npart which starts from the referenced register must be\\nimplementing this algorithm can be written in the list language\\ntreated as a new list, and a new reference counter must be\\nwith which it is to be used, thus insuring a degree of machine\\nset up. T h e proliferation of reference counters, and\\nindependence. Finally, the application of the algorithm to a\\nthe large amount of bookkeeping involved, makes this\\nnumber of different list structures appearing in the literature is\\nmethod extremely cumbersome. In a two-way list [6] it is\\nindicated.\\nahvays possible to locate the head, and thus it is not neces-\\n1. I n t r o d u c t i o n\\nsary to set up a new reference counter. However, the head\\nof the list must be found and the reference count increased\\nOne of the most important features of a list language is\\nby 1. Besides being time-consuming, this may prevent re-\\nits ability to allocate storage dynamically during the run-\\nturning part of a list to the free list. For example, in Figure\\nning of the object program. This is accomplished by means\\n1 there is no way of discarding the top part of list B if list\\nof a list of\\navailable space (or free list) which contains those\\nA still needs the bottom part of B. Thus in practice this\\nregisters not being used. Initially, the free list contains all\\nstorage not occupied by the program [1, 2, 11], and regis-\\npart of B has to be treated as a separate list and a new\\nters are detached from it and formed into list structures\\nreference counter is needed [5, 6]. T h e reference counter\\nas the program is executed. T h e execution of the program\\nmethod breaks down completely in the case of a circular\\nmust usually be suspended when the free list is exhausted,\\nlist (i.e., one in which the list is a sublist of itself). In this\\nand the problem arises of reclaiming those parts of the list\\nsituation the reference counter cannot be decreased to zero,\\nstructure which are no longer needed (if any such exist). In\\neven though the entire list m a y become inaccessible [13].\\nthis paper a statement of the difficulties involved is fol-\\nT h e third solution, which appears to be the most attrac-\\nlowed by a brief review of the solutions which have been\\ntive, was proposed by M c C a r t h y [2] and is considered in\\nproposed. A new, machine-independent procedure and the\\ndetail below. In this method, no reference counters are\\nresults obtained using the 7094 version of this procedure\\nkept and registers are not returned to the free list until the\\nare presented. Finally, the application and modification of\\nlatter has been exhausted. T h e n a procedure known as\\nthis routine for a variety of list structures is discussed.\\n\\\"garbage collection\\\" is initiated, which traces the entire\\n* Department of Electrical Engineering\\nlist structure, marking those registers which are attached\\n\\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 501\\n\\n-------- Page Break --------\\n\\nto some list. Registers no longer needed will not be attached\\nwords making up such an element can be allowed to vary\\nto any list and will thus remain unmarked. When all lists\\nfrom element to element. These variable-length elements\\nhave been traced, a routine is entered to form all unmarked\\nwere proposed by Comfort [9], who also gave a solution to\\nregisters into a new free list and erase the marks in all\\nthe problem which is created of maintaining a generalized\\nothers (in ease the garbage collector has to be used again\\nfree list. In such a free list, an item of arbitrary length m a y\\nlater).\\nbe taken off, and to insure t h a t large elements are available\\nSeveral difficulties arise in using and implementing a\\nit is important to t r y to reconstruct the largest possible\\ngarbage collection procedure.\\nblocks of consecutive free registers when returning regis-\\n(A) T h e basic problem is the tracing of the lists. In\\nters to the free list. The problem of using a garbage collee-\\ngeneral the lists will be branched and all branches must be\\ntion procedure to achieve this is discussed below.\\ntraced. Several methods have been suggested, but all re-\\n3. A T e c h n i q u e for G a r b a g e C o l l e c t i o n i n a O n e -\\nquire either a significant amount of additional storage (for\\nW a y L i s t\\nremembering the branch points encountered) or the re-\\ntracing of large portions of the list structure m a n y times.    Solution of the basic problem (see Section 2A) of garbage\\ncollection requires a routine t h a t is economical both in its\\n(B) A second problem arises when the data consists of\\nsigned numbers which are stored in a whole word. In  use of temporary storage and in the number of times it\\ntraverses the list structure. In addition, of course, it must\\nMcCarthy's method of garbage collection, the sign of each\\nregister that is attached to a list is set to minus, while un-  be able to trace any possible list. A routine which uses a\\nlimited amount of temporary storage for remembering the\\nattached registers remain positive. The sign of an attached\\nlocation of branch points cannot trace a list which has too\\nregister is then reset to plus after the new free list has been\\nm a n y such points, and a reeursive routine requires a push-\\nformed. Clearly, this procedure, unless modified, will result\\nin reversing the sign of any negative numbers. The modifi- down stack of indeterminate length on which to store re-\\nturn addresses. Moreover, if a routine must traverse a par-\\ncation proposed by M c C a r t h y is to reserve a block of stor-\\ntieular list an indeterminate number of times it will fail\\nage t h a t is to be used exclusively for whole-word data items\\nwhen it encounters a circular list. In connection with an\\n(full-word space). A second part of the store is then set aside\\nimplementation of the Wisp language [7, S] for the I B M\\nfor a bit table, to be used during garbage collection to re-\\n7094, a method has been developed which uses two index\\ncord which of the full words are still part of active list\\nregisters and the accumulator for temporary storage and\\nstructures. This modification is not completely satisfactory\\nwhich traverses the list structure twice. This routine is\\nsince (1) it violates the dynamic storage allocation princi-\\ncapable of tracing any list structure (including circu-\\nple of list processing languages, and (2) the storage used\\nlar lists) which has any number of branch points.\\nby the bit table and the additional part of the garbage\\nIn the Wisp system as programmed for the 7094, the\\ncollection program which utilizes it must be taken away\\naddress field (TAIL) of a list element contains the loca-\\nfrom the free list.\\ntion of the next register on the list and is called a pointer.\\n(C) Besides single full-word data items, multiple-word\\nT h e decrement field (HEAD) contains either an atom [2]\\nlist elements have been proposed, and the number of\\nor the location of a branch of the list. A Wise list is shown\\nin Figure 2(a). T h e prefix and tag fields are unused and\\nhence are available for use by the garbage collector. T h e\\nB\\nalgorithm employed here is to move down a list ignoring\\nsublists and reversing the pointers as one goes. This re-\\nversal of pointers in a one-way list structure with shared\\nsublists permits a return to be made to the head of a list\\nduring garbage collection. During this first pass, the sign\\nof each register is made negative. T h e end of the first pass\\ni\\nis reached when either (1) the end of the list is reached, or\\n(2) a register on the list is encountered whose sign is minus\\n(indicating that this part of the list is a sublist of some\\ni t\\nother list that has already been traversed). T h e result of\\napplying this forward scan to the list D shown in Figure\\n2(a) is given in Figure 2(b).\\n1 I\\nDuring the forward scan of the list, the contents of the\\nH E A D of each list register are ignored. T h e reverse scan,\\nwhich is entered when the forward scan is terminated,\\nI i\\nmoves back up the list restoring the original pointers. ID\\naddition, it examines the H E A D of each register, checking\\nto see if it contains a reference to a sublist. (In the 7094\\nimplementation of WisP, any number larger than 2200 is a\\npointer to a sublist, while any number less than this is an\\nFiG. 1. Sharing a sublist in a two-way list structure\\n\\n502 Communications of the ACM Volume 10 / Number 8 / August, 1967\\n\\n-------- Page Break --------\\n\\n\\n\\n-------- Page Break --------\\n\\nnominal--68 words for the routine itself, in addition to the\\n4. T h e R o u t i n e a n d its E f f i c i e n c y\\ntwo index registers and accumulator.\\nT h e routine itself is flowcharted in Figure 3. For con-\\nFor purposes of comparison, a trace routine proposed by\\nvenience in drawing the flowchart, the list elements are\\nWilkes was coded for the 7094. I t required only two tempo-\\nassumed to be numbered sequentially. Thus, list element\\nrary storage locations, and occupied 35 words of memory.\\nI + 1 follows list element I (i.e., list element I + 1 is pointed\\nThis routine traversed a path from the head of a list to each\\nto by the T A I L of list element I). T h e routine uses two in-\\nterminal register separately. Thus much of the list was\\ndex registers and the accumulator for temporary storage,\\nscanned m a n y times, and the program would fail by enter-\\nthough in general any three storage locations could be used.\\ning a loop when attempting to trace a circular list. When\\nOne contains the address of the previous list element ex-\\nrun under the above conditions (5 binary trees of depth 12)\\namined, the second the address of the element currently\\nthe routine required 2.75 seconds for a complete trace.\\nbeing examined and the third the address of the next ele-\\nAs a final comparison, a routine which stored branch\\nment on the list. This is necessary for the reversal of the\\npoints was coded and run using the same list structure. T h e\\npointers during the forward scan and their restoration\\nprogram occupied 34 words, and an additional 48 words\\nduring the reverse scan.\\nwere allotted as a storage area for the branch points. Any\\nIn order to evaluate the speed of the routine, a Wise\\ngiven part of the list structure was only traversed once, so\\nprogram was written which created five complete binary\\nt h a t this routine could trace any list for which the number\\ntrees of depth 12. T h e remaining registers were discarded\\nof branch points it was required to store was less t h a n 49.\\nand the garbage collector called. Thus it was forced to\\nOnly .448 seconds were required to complete the trace of\\ntrace a list structure containing over 20,000 registers, half\\nthe test structure.\\nof which were branch points. T h e elapsed time, according\\nto the system clock, was 1.85 seconds. This list structure\\nseems far more complex than any which would be en-\\ncountered in practice, and therefore a normal garbage col-\\nlection should take far less time. T h e space occupied is also\\n\\nENTRY\\nYES\\n\\ni\\n\\nSET I TO I\\ni\\nFIRST CELL\\nOF L ST\\nEXIT\\n\\nQ\\nYES\\n\\nRESTORE POINTER\\nlNO\\nRESTORE POINTER\\nIN CAR OFI.\\nOF CELL I\\nCLEAR BRANCH\\nI - ~ I\\nPOINT FLAG.\\nL\\nI MAKE'TI\\nMINUS\\n\\nF\\nNO\\n1\\nI REVERSE POINTER\\nOFCELLI\\nW:l  ~~~iYESTO\\nREVERSE POINTERI\\nIN CAR OF I\\nSET BRANCH\\nPO NT FLAG\\n\\n1\\nSET 2: TO\\nYES\\nFIRST CELL\\nOF BRANCH\\n\\n(\\nFIG. 3. T r a c e a l g o r i t h m f o r a o n e - w a y l i s t . F o r w a r d s c a n ; r e v e r s e s c a n\\n\\n504 Communications of the ACM Volume 10 / Number 8 / August, 1967\\n\\n-------- Page Break --------\\n\\nreturned. To see this, consider first the way in which the\\nOn the basis of these results, it seems that the best gar-\\nfree list is originally formed. If all of the unused storage\\nbage collection procedure is to use the last routine with as\\nconstitutes a consecutive block [11], then the free list can be\\nmuch temporary storage as possible, and when this storage\\nconstructed so t h a t a new free list element occurs at every\\nis full to trace the remainder of the current branch using\\nn t h memory address from the start of the block. Thus it\\nthe algorithm given in Section 4. In this way one is able to\\nsuffices to look at the every n t h location in the free storage\\nrealize the most efficient collection for the amount of tem-\\nspace; a positive register and the succeeding n - 1 registers\\nporary memory available, and yet there is no possibility\\ncan be returned to the free list.\\nof failure for any structure. If, however, no temporary\\nConsider next, garbage collection when n can vary from\\nstorage area can be excluded from the free list or it is in-\\none list element to the next. In this case, the H E A D of the\\nconvenient to code two garbage collectors, then the al-\\nfirst register does not ordinarily contain data, but rather\\ngorithm of the previous section offers a reasonably efficient\\ncontains the number n of registers that make up the ele-\\nfail-safe solution.\\nment. It is necessary then to distinguish between the fol-\\n5. S y m b o l i c G a r b a g e C o l l e c t o r\\nlowing items that m a y occupy the H E A D : (1) the number\\nThe transfer of a programming system from one machine\\nn, as above, of consecutive registers, for n > 1, and (2) the\\nto another can be more easily achieved if the compiler and\\ndata item itself (which m a y be a pointer to a sublist) if\\nits utility routines are written in a higher level (nonma-\\nn = l .\\nchine) language [7, 12]. For this reason it is desirable to\\nThis information can be stored in one bit of the prefix\\nprogram the garbage collection routine for a list processing\\nfield of a 7094 word, leaving one bit for the garbage collec-\\nlanguage in the language itself. The routine, if it is to work\\ntor's branch point flag. T h e scan shown in Figure 3 can\\nin all cases, must use a fixed amount of temporary storage.\\nagain be employed to mark the first registers of those ele-\\nA recursive routine does not satisfy this condition because\\nments attached to lists t h a t have not been discarded. Next,\\nit requires a pushdown stack of indeterminate length on\\ninstead of merely returning all non-negative registers to the\\nwhich to store return addresses. We have seen t h a t the\\nfree list, the sequential scan of storage, which is flow-\\nWisp garbage collection is divided into two phases: t h a t\\ncharted in Figure 4, must be used. This scan does not re-\\nin which the list structure is traced and marked, and t h a t\\nt u r n a negative register to the free l i s t ~ n o r any of the next\\nin which the new free list is formed from the unmarked\\nn - - 1 consecutive storage registers that make up the rest\\nregisters. The second phase is severely machine-dependent,\\nof the list element. Furthermore, this scan collects the\\nbut the first can easily be written in a list language. T h e\\nlargest block of consecutive discarded registers and forms\\ntrace algorithm presented in Section 3 requires the addition\\nthem into a single free list element.\\nof several elementary operations to those normally found\\nin Wise. These were:\\nENTRY\\n(1) set an element minus,\\nSET I TO THE\\n(2) set a branch point flag,\\nBEGINNINGOFTHE\\nLIST STORAGE\\n(3) delete a branch point flag,\\nAREA O~COUNT\\n(\\n(4) test the sign,\\n(5) test the branch point flag, and\\nYES\\n(6) sequence from one list to the next.\\n_ _ ~ C O U N\\nMAKE IT\\nYES B MAI\\nOnce these functions have been defined in machine lan-\\nguage, the Wisp compiler can translate the entire routine\\nNO\\n(which contains 35 WzsP statements).\\nIPL.ACECUUNTINTO[\\nADD CELL Z ANU\\nTHE COUNTFIELD\\nTHE NEXT ~-I\\nI\\nOF THECURRENT\\nCELLS TO THE\\n6.\\nG a r b a g e C o l l e c t i o n i n a Variable I t e m L i s t\\nFREE LIST\\nCURRENTFREE\\nELEMENT\\nLIST\\nEiEMENT\\nVarious list processing systems have been proposed in\\nwhich each list element consists of a number of consecutive\\nCOUNT+~-.m,..\\nregisters [5, 6, 9, 10]. T h a t is, if each element is to consist of\\nCOUNT\\nn registers and the element is stored at memory location M,\\nthen the element is composed of the n consecutive registers\\nM , M - t - l , . . . , M + n - - 1 . In some systems n is fixed for\\nQ\\nall list elements (n = 2 is a common choice), while in\\nothers n m a y v a r y from one list element to the next.\\nIf n, n > 1, is fixed, the problem of garbage collection is\\nPLACE C O U N T I N T O ~ _ ~\\nWE R:ACHE\\nTHE COUNTFIELD NO\\nsimilar to the case considered above where n = 1. T h e\\nyES THE END\\n~jgE\\nOF THE CURRENT TO ZERO\\nFREE LIST\\nscan of Figure 3 is used to mark the first register of each\\nELEMENT\\nYES\\nlist element minus. Whenever a negative register is found\\nin the sequential scan of the store that follows, it and the\\n1 I\\nEXIT EXiT\\nnext n - - 1 sequential registers are not returned to the free\\nlist. If a positive register is found, it and the next n - 1 are     FzG. 4. Routine to reclaim variable-length items\\n\\nVolume 10 / Number 8 / August, 1967 Communications of the ACM 505\\n\\n-------- Page Break --------\\n\\n7. G a r b a g e C o l l e c t i o n f o r O t h e r L i s t S t r u c t u r e s\\nsaved address is used to restore the above Header field\\nwhile the branch element address stored in that field is\\nAs mentioned above, some list languages permit the\\nused to resume scanning and marking the list on which the\\nH E A D of a list element to contain the address of a full\\nbranch element appeared.\\nword of data. Since a data word may be a negative number,\\nthis presents difficulties during garbage collection. To avoid\\n8. C o n c l u s i o n\\nthis difficulty, variable length list elements should be used\\nIn this paper, various procedures for garbage collection\\nto achieve full-word storage; this case then reduces to t h a t\\nhave been presented. These procedures are useful for the\\nof Section 6.\\nlist processing systems and structures previously reported\\nIn a threaded list system [10], sublists cannot be shared,\\nin the literature. An algorithm which will trace any one-\\nand garbage collection is particularly simple since the last\\nway list has been presented, and its efficiency discussed. In\\nelement always points to the head of a list or sublist. Dur-\\nview of this routine's storage requirements and speed it\\ning the forward scan it is not necessary to reverse the\\nseems that the method of garbage collection is far more\\npointers, nor is a reverse scan needed since both only serve\\nefficient than the use of reference counters in one-way lists.\\nto effect a return to the head of a (sub)fist. A flowchart of\\nGarbage collection in other types of list structures appears\\nthe first part of a garbage collection procedure for this\\nto be implemented by even simpler procedures.\\ntype of system is given in Figure 5.\\nB y a slight extension of the elementary functions avail-\\nT h e routine can also be employed, with a slight modifi-\\nable to a list processing language, the garbage collection\\ncation, to collect garbage in a two-way SLIP list [5, 6]. In\\nprocedure m a y be described within the language in a non-\\nsuch a list the first list element, called a Header, has two\\nrecursive way, thus facilitating its transfer from one ma-\\npointers. One points to the next list element while the\\nchine to another. On the basis of these results, the use of\\nsecond points to the last element. T h e last element points\\ngarbage collection for reclaiming registers should always\\nback to the Header. Garbage collection can be achieved by\\nbe considered when implementing a list processing system.\\nmodifying Figure 5 in the following manner.\\n(1) When a list is first encountered, it is checked to see\\nAcknowledgment. T h e authors gratefully acknowledge\\nif it has already been traversed.\\nthe cooperation of Professor M. V. Wilkes and his col-\\n(2) When a branch is descended, the Header address\\nleagues at the Cambridge University Mathematical Labo-\\nfield which points to the last element is changed to point\\nratory in transferring the Wrap system to the I B M 7094.\\nback to the branch element. (This enables a return to be\\nThis project was made possible by an allotment of time\\nmade to the main list).\\nfrom the Columbia University Computer Center.\\n(3) In traversing the list, the address of the previous\\nRECEIVED FEBRUARY, 1965; REVISEDMAY, 1967\\nlist element marked is saved, When the pointer from the\\nlast element back to the Header has been followed, this\\nR E F E R E N C E S\\nInformation Processing Language--W\\n1. NEWELL, A. (ED.)\\nENTRY\\n2nd ed. Prentice Hall, Englewood N. J., 1964.\\nManual,\\nI\\n2. McCARTHY, J. Recursive functions of symbolic expressions\\nand their computation by machine, part I.\\nComm. A C M 3\\nSET I TO THE\\nFIRST\\n(April, 1960), 184.\\nELEMENT\\n3. GERLERNTEa,II., ET AL. A FORTRAN-compiled list-process-\\nJ. A C M 7 (April 1960), 87.\\ning language.\\n4. COLLINS,G.E. A method for overlapping and erasure of lists.\\nComm. A C M 8 (Dec. 1960), 655.\\nComm. A C M 5\\n5. WEIZENBAUM, J. Knotted list structures.\\nSET I TO THE\\n'E\\n(Mar. 1962), 161.\\nFIRST ELEMENT\\nOF THE BRANCH\\n6. WEIZENBAUM, J. Symmetric list processor.\\nComm. A C M 6\\n(Sept. 1963), 524.\\n7. WILKES, M.V. An experiment with a self-compiling compiler\\nYES\\nfor a simple list-processing language.\\nAnnual Review in\\nAutomatic Programming, Vol. 4.\\nPergamon Press, N.Y.\\nNO\\n1964, pp. 1-48.\\n8. WILKES, M. V. Lists and why they are useful. Proc. ACM\\n19th Nat. Conf., August 1964, ACM Publ. P-64, F1-1.\\nNO OF THiS ;RANCH Jii\\n9. COMFORT,W . T . Multiword list items.\\nComm. A C M 7 (June\\n1964), 357.\\n10. EVANS,A., PERLIS, A. J., ANDVAN ZOEREN,It. Use of threaded\\nlists in constructing a combined ALGOL and machine-like\\nRES~: TO I\\nComm. A C M 4 (Jan. 1961), 36.\\nassembly processor.\\n\\\"~ ELEMENT\\n11. WAITE, W., AND SCrmRR, H. A note on the formation of a free\\nBRANCH POINT\\nlist.\\nComm. A C M 8 (Aug. 1964), 478.\\nMachineJndependent Computer Program-\\n12. I-IALSTEAD,M. It.\\nming. Spartan Books, Washington 1). C., 1962.\\nEXIT\\n13. McBETH, J. M. On the reference counter method.\\nComm.\\nA C M 6\\n(Sept. 1963), 575.\\nA scan for threaded lists\\nFIG. 5.\\n\\n506 C o m m u n i c a t i o n s o f t h e A C M V o l u m e 10 / N u m b e r 8 / A u g u s t , 1967\\n```\\n\\nGiven the paper in DOCS, generate a 140 character tweet that\\ncaptures the paper idea and make it interesting.\\n\"\n        }\n      ]\n    }\n  ],\n  \"stream\": true\n}\n``````\n\n</details>\n\n-   response: 200 OK\n\n</details>\n\n\n\n<details id=\"-llm-response\" class=\"genaiscript\">\n<summary>\n llm response\n</summary>\n\n\n\n<details id=\"output\" class=\"genaiscript\">\n<summary>\noutput\n</summary>\n\n\n```markdown\n\"Discover the art of efficient garbage collection in list structures without the hassle of manual tracking or cumbersome counters! #ComputerScience #Innovation\"\n```\n\n</details>\n\n\n</details>\n\n\n\n<details id=\"-json-(parsed)\" class=\"genaiscript\">\n<summary>\n json (parsed)\n</summary>\n\n\n```json\nDiscover the art of efficient garbage collection in list structures without the hassle of manual tracking or cumbersome counters! #ComputerScience #Innovation\n```\n\n</details>\n\n\n\n<details id=\"-edits\" class=\"genaiscript\">\n<summary>\n edits\n</summary>\n\n| type | filename | message |\n| :--------- | :----------------------------------- | :------ |\n| createfile | src/bztest/gc1.pdf.pdf-to-tweet.json | |\n</details>\n\n",
  "text": "\"Discover the art of efficient garbage collection in list structures without the hassle of manual tracking or cumbersome counters! #ComputerScience #Innovation\"",
  "version": "1.18.2",
  "fences": [],
  "frames": [],
  "genVars": {}
}