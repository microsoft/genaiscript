{"sha":"44fd7d34b9b688ed28b415b573b0ef1fc8c2d5e1c039f499bede9ed44e90ab61","key":{"template":{"id":"generate-python-tests","title":"Generate python tests"},"fragment":{"fullId":"email_recognizer.py.gpspec.md:0:0","hash":"1f2e6fc915fb612f"}},"val":{"response":{"edits":[{"label":"Create /workspaces/coarch/packages/helloworld/test_email_recognizer.py","filename":"/workspaces/coarch/packages/helloworld/test_email_recognizer.py","type":"createfile","text":"import unittest\nfrom email_recognizer import is_valid_email\n\nclass TestEmailRecognizer(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"john.doe@example.com\"))\n\n    def test_invalid_email_no_at(self):\n        self.assertFalse(is_valid_email(\"johndoeexample.com\"))\n\n    def test_invalid_email_no_domain(self):\n        self.assertFalse(is_valid_email(\"john.doe@\"))\n\n    def test_invalid_email_special_chars(self):\n        self.assertFalse(is_valid_email(\"john.doe@exa$mple.com\"))\n\n    def test_invalid_email_no_username(self):\n        self.assertFalse(is_valid_email(\"@example.com\"))\n\nif __name__ == '__main__':\n    unittest.main()\n","overwrite":true},{"label":"Create /workspaces/coarch/packages/helloworld/email_recognizer.py.gpspec.md","filename":"/workspaces/coarch/packages/helloworld/email_recognizer.py.gpspec.md","type":"createfile","text":"# email_recognizer.py\n\n-   [email_recognizer.py](./email_recognizer.py)\n","overwrite":true},{"label":"Generate python tests","filename":"/workspaces/coarch/packages/helloworld/email_recognizer.py.gpspec.md","type":"insert","pos":[2,48],"text":"\n-   [test_email_recognizer.py](test_email_recognizer.py)"}],"fileEdits":{"/workspaces/coarch/packages/helloworld/test_email_recognizer.py":{"before":null,"after":"import unittest\nfrom email_recognizer import is_valid_email\n\nclass TestEmailRecognizer(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"john.doe@example.com\"))\n\n    def test_invalid_email_no_at(self):\n        self.assertFalse(is_valid_email(\"johndoeexample.com\"))\n\n    def test_invalid_email_no_domain(self):\n        self.assertFalse(is_valid_email(\"john.doe@\"))\n\n    def test_invalid_email_special_chars(self):\n        self.assertFalse(is_valid_email(\"john.doe@exa$mple.com\"))\n\n    def test_invalid_email_no_username(self):\n        self.assertFalse(is_valid_email(\"@example.com\"))\n\nif __name__ == '__main__':\n    unittest.main()\n"}},"trace":"\n# Prompt trace\n\n\n\n## Prompt template \"Generate python tests\" (`generate-python-tests`)\n\n```````````````js\n  1: gptool({\n  2:     title: \"Generate python tests\",\n  3:     model: \"gpt-4\",\n  4:     description: \"Given a task and code, generate tests\",\n  5:     categories: [\"hello world\"],\n  6:     system: [\"system\", \"system.explanations\", \"system.summary\", \"system.files\", \"system.python\"],\n  7:     temperature: 0\n  8: })\n  9: \n 10: def(\"TESTS\", env.links.filter((f) => /^test_*\\.py$/.test(f.filename)))\n 11: def(\"TASK\", env.file)\n 12: def(\n 13:     \"CODE\",\n 14:     env.links.filter(\n 15:         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n 16:     )\n 17: )\n 18: \n 19: $`Python has been written for the task in TASK. The code is in CODE.\n 20: Generate 5 tests for the code in CODE in a separate file.\n 21: Do not modify or duplicate the code in CODE.\n 22: \n 23: If the tests are already present in TESTS, ensure that the tests\n 24: match the description in TASK and the code in CODE.  If they do not,\n 25: update the tests to match the code and the description.\n 26: \n 27: Use this format for test file names: \"test_*.py\".\n 28:  \n 29: Include the unittest test harness that can run the tests from the command line.`\n 30: \n```````````````\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n\n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.hello world** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nTASK:\n````` file=email_recognizer.py.gpspec.md\n# email_recognizer.py\n\n-   [email_recognizer.py](./email_recognizer.py)\n`````\n\nCODE:\n````` file=email_recognizer.py\nimport re\n\ndef is_valid_email(email: str) -> bool:\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n`````\n\nPython has been written for the task in TASK. The code is in CODE.\nGenerate 5 tests for the code in CODE in a separate file.\nDo not modify or duplicate the code in CODE.\n\nIf the tests are already present in TESTS, ensure that the tests\nmatch the description in TASK and the code in CODE.  If they do not,\nupdate the tests to match the code and the description.\n\nUse this format for test file names: \"test_*.py\".\n \nInclude the unittest test harness that can run the tests from the command line.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-UGHGBQ`\n\n-   env.**file**\n```````````````js\n{ filename: \"email_recognizer.py.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email_recognizer.py\\n\\n-   [email_recognizer.py](./email_rec\"... }\n```````````````\n\n-   env.**links**\n```````````````js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email: str) -> bool:\\n    patte\"... } ]\n```````````````\n\n-   env.**parents**\n```````````````js\n[  ]\n```````````````\n\n-   env.**fence**\n```````````````\n`````\n```````````````\n\n-   env.**promptOptions**\n```````````````js\n{  }\n```````````````\n\n-   env.**vars**\n```````````````js\n{  }\n```````````````\n\n-   env.**templates**\n```````````````js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... } ]\n```````````````\n\n-   env.**template**\n```````````````js\n{ id: \"generate-python-tests\",\ntitle: \"Generate python tests\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Generate python tests\\\",\\n    model: \\\"gpt\"...,\nfilename: \"/workspaces/coarch/packages/helloworld/gptools/generate-pyth\"...,\nmodel: \"gpt-4\",\ndescription: \"Given a task and code, generate tests\",\ncategories: [ \"hello world\" ],\nsystem: [ \"system\",\n  \"system.explanations\",\n  \"system.summary\",\n  \"system.files\",\n  \"system.python\" ],\ntemperature: 0,\ninput: \".md\" }\n```````````````\n\n## System prompt\n###  template: `system`\n\n```````````````js\n  1: system({ title: \"System prompt\" })\n  2: $`You are concise. Answer in markdown.`\n```````````````\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.explanations`\n\n```````````````js\n  1: system({ title: \"Explain your answers\" })\n  2: $`When explaining answers, take a deep breath.`\n  3: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen explaining answers, take a deep breath.\n```````````````\n###  template: `system.summary`\n\n```````````````js\n  1: system({\n  2:     title: \"Summarize\",\n  3:     description: \"Generate a summary of the changes\",\n  4: })\n  5: \n  6: $`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n  7: \n  8: def(`SUMMARY`, `This is a summary of the changes in files.`)\n  9: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n`````\nThis is a summary of the changes in files.\n`````\n```````````````\n###  template: `system.files`\n\n```````````````js\n  1: system({ title: \"File generation\", description: \"Teaches the file format supported by CoArch\" })\n  2: \n  3: const folder =\n  4:     env.vars[\"system.multifile.outputFolder\"] ||\n  5:     env.template.outputFolder\n  6: $`When generating or updating files you will use the following syntax:`\n  7: \n  8: def(`File ${folder || \".\"}/file1.ts`, `What goes in\\n${folder || \".\"}/file1.ts.`)\n  9: def(`File /path_to_file/file2.md`, `What goes in\\n/path_to_file/file2.md.`)\n 10: \n 11: $`Make sure to use precisely ${env.fence} to guard file code sections.`\n 12: $`Use full path of filename in code section header.`\n 13: if (folder)\n 14:     $`When generating new files, place files in folder \"${folder}\".`\n 15: $`If a file does not have changes, do not regenerate.`\n 16: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen generating or updating files you will use the following syntax:\n\nFile ./file1.ts:\n`````\nWhat goes in\n./file1.ts.\n`````\n\nFile /path_to_file/file2.md:\n`````\nWhat goes in\n/path_to_file/file2.md.\n`````\n\nMake sure to use precisely ````` to guard file code sections.\n\nUse full path of filename in code section header.\n\nIf a file does not have changes, do not regenerate.\n```````````````\n###  template: `system.python`\n\n```````````````js\n  1: system({\n  2:     title: \"Python Developer\",\n  3:     description: \"Expert at generating and understanding Python code.\"\n  4: })\n  5: \n  6: $`Also, you are an expert coder in Python. You create code that is PEP8 compliant.`\n  7: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nAlso, you are an expert coder in Python. You create code that is PEP8 compliant.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 800\n\n```````````````markdown\nTASK:\n````` file=email_recognizer.py.gpspec.md\n# email_recognizer.py\n\n-   [email_recognizer.py](./email_recognizer.py)\n`````\n\nCODE:\n````` file=email_recognizer.py\nimport re\n\ndef is_valid_email(email: str) -> bool:\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n`````\n\nPython has been written for the task in TASK. The code is in CODE.\nGenerate 5 tests for the code in CODE in a separate file.\nDo not modify or duplicate the code in CODE.\n\nIf the tests are already present in TESTS, ensure that the tests\nmatch the description in TASK and the code in CODE.  If they do not,\nupdate the tests to match the code and the description.\n\nUse this format for test file names: \"test_*.py\".\n \nInclude the unittest test harness that can run the tests from the command line.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nFile ./test_email_recognizer.py:\n`````\nimport unittest\nfrom email_recognizer import is_valid_email\n\nclass TestEmailRecognizer(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"john.doe@example.com\"))\n\n    def test_invalid_email_no_at(self):\n        self.assertFalse(is_valid_email(\"johndoeexample.com\"))\n\n    def test_invalid_email_no_domain(self):\n        self.assertFalse(is_valid_email(\"john.doe@\"))\n\n    def test_invalid_email_special_chars(self):\n        self.assertFalse(is_valid_email(\"john.doe@exa$mple.com\"))\n\n    def test_invalid_email_no_username(self):\n        self.assertFalse(is_valid_email(\"@example.com\"))\n\nif __name__ == '__main__':\n    unittest.main()\n`````\n\nSUMMARY:\n`````\nCreated a test file (test_email_recognizer.py) with 5 tests for the is_valid_email function in email_recognizer.py.\n`````\n```````````````\n\n\n### Extracted Variables\n\n-   `File ./test_email_recognizer.py`\n`````py\nimport unittest\nfrom email_recognizer import is_valid_email\n\nclass TestEmailRecognizer(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"john.doe@example.com\"))\n\n    def test_invalid_email_no_at(self):\n        self.assertFalse(is_valid_email(\"johndoeexample.com\"))\n\n    def test_invalid_email_no_domain(self):\n        self.assertFalse(is_valid_email(\"john.doe@\"))\n\n    def test_invalid_email_special_chars(self):\n        self.assertFalse(is_valid_email(\"john.doe@exa$mple.com\"))\n\n    def test_invalid_email_no_username(self):\n        self.assertFalse(is_valid_email(\"@example.com\"))\n\nif __name__ == '__main__':\n    unittest.main()\n\n`````\n\n-   `SUMMARY`\n`````\nCreated a test file (test_email_recognizer.py) with 5 tests for the is_valid_email function in email_recognizer.py.\n\n`````\n\n","text":"File ./test_email_recognizer.py:\n`````\nimport unittest\nfrom email_recognizer import is_valid_email\n\nclass TestEmailRecognizer(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"john.doe@example.com\"))\n\n    def test_invalid_email_no_at(self):\n        self.assertFalse(is_valid_email(\"johndoeexample.com\"))\n\n    def test_invalid_email_no_domain(self):\n        self.assertFalse(is_valid_email(\"john.doe@\"))\n\n    def test_invalid_email_special_chars(self):\n        self.assertFalse(is_valid_email(\"john.doe@exa$mple.com\"))\n\n    def test_invalid_email_no_username(self):\n        self.assertFalse(is_valid_email(\"@example.com\"))\n\nif __name__ == '__main__':\n    unittest.main()\n`````\n\nSUMMARY:\n`````\nCreated a test file (test_email_recognizer.py) with 5 tests for the is_valid_email function in email_recognizer.py.\n`````","summary":"Created a test file (test_email_recognizer.py) with 5 tests for the is_valid_email function in email_recognizer.py.\n"}}}
{"sha":"a7bc545aff6c39ba8bfe2f31a973fd285c03a6a7390b677381b6b2b0bd12763f","key":{"template":{"id":"front-matter","title":"SEO front matter"},"fragment":{"fullId":"README.md.gpspec.md:0:0","hash":"f853854a0efa414d"}},"val":{"response":{"edits":[{"label":"Update /workspaces/coarch/packages/helloworld/README.md","filename":"/workspaces/coarch/packages/helloworld/README.md","type":"replace","range":[[0,0],[124,0]],"text":"---\ntitle: Python Email Validation Guide with GPTools\ndescription: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n"}],"fileEdits":{"/workspaces/coarch/packages/helloworld/README.md":{"before":"---\ntitle: Python Email Validation Demo with GPTools\ndescription: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Argparse\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n","after":"---\ntitle: Python Email Validation Guide with GPTools\ndescription: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n"}},"trace":"\n# Prompt trace\n\n\n\n## Prompt template \"SEO front matter\" (`front-matter`)\n\n```````````````js\n  1: gptool({\n  2:     title: \"SEO front matter\",\n  3:     description: \"Update or generate SEO-optimized front matter for a markdown file.\",\n  4:     categories: [\"markdown\"],\n  5:     system: [\"system\", \"system.diff\"],\n  6:     maxTokens: 2000,\n  7:     temperature: 0,\n  8: })\n  9: \n 10: def(\"SOURCE\", env.links.filter(f => f.filename.endsWith(\".md\")))\n 11: \n 12: $`\n 13: You are a helpful front matter generator. You are an SEO expert.\n 14: \n 15: Generate DIFF for SOURCE front matter:\n 16: - Update fields title, description and keywords as needed\n 17: - use yaml format, do not use quotes\n 18: - only 5 keywords or less\n 19: - optimize for search engine optimization.\n 20: - Do not modify the markdown content after the front matter.\n 21: \n 22: If no front matter is present, generate it.\n 23: `\n 24: \n```````````````\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n\n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.markdown** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nSOURCE:\n````` file=README.md\n---\ntitle: Python Email Validation Demo with GPTools\ndescription: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Argparse\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n`````\n\nYou are a helpful front matter generator. You are an SEO expert.\n\nGenerate DIFF for SOURCE front matter:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do not modify the markdown content after the front matter.\n\nIf no front matter is present, generate it.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-CUYTEG`\n\n-   env.**file**\n```````````````js\n{ filename: \"README.md.gpspec.md\",\nlabel: \"current\",\ncontent: \"# README.md\\n\\n-   [README.md](./README.md)\\n\" }\n```````````````\n\n-   env.**links**\n```````````````js\n[ { label: \"README.md\",\n  filename: \"README.md\",\n  content: \"---\\ntitle: Python Email Validation Demo with GPTools\\ndescrip\"... } ]\n```````````````\n\n-   env.**parents**\n```````````````js\n[  ]\n```````````````\n\n-   env.**fence**\n```````````````\n`````\n```````````````\n\n-   env.**promptOptions**\n```````````````js\n{  }\n```````````````\n\n-   env.**vars**\n```````````````js\n{  }\n```````````````\n\n-   env.**templates**\n```````````````js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... } ]\n```````````````\n\n-   env.**template**\n```````````````js\n{ id: \"front-matter\",\ntitle: \"SEO front matter\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"SEO front matter\\\",\\n    description: \\\"Up\"...,\ndescription: \"Update or generate SEO-optimized front matter for a markdown\"...,\ncategories: [ \"markdown\" ],\nsystem: [ \"system\",\n  \"system.diff\" ],\nmaxTokens: 2000,\ntemperature: 0,\ninput: \".md\" }\n```````````````\n\n## System prompt\n###  template: `system`\n\n```````````````js\n  1: system({ title: \"System prompt\" })\n  2: $`You are concise. Answer in markdown.`\n```````````````\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.diff`\n\n```````````````js\n  1: system({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n  2: \n  3: $`The DIFF format should be used to generate diff changes on files: added lines start with +\n  4: , deleted lines start with -\n  5: , do not add line numbers\n  6: , preserve indentation\n  7: , use relative file path name\n  8: , only generate diff for files that have changes\n  9: , do not generate diff for files that have no changes\n 10: , only emit a couple unmodified lines before and after the changes\n 11: , do not emit the whole file content\n 12: , deleted lines must exist in the original file (do not invent deleted lines)\n 13: , added lines must not exist in the original file\n 14: , keep the diffs as small as possible:\n 15: \n 16: DIFF ./file.ts:\n 17: ${env.fence}diff\n 18:   2 lines before changes (not the whole file)\n 19: - deleted line\n 20: - delete line 2\n 21: + added line\n 22: + added line 2\n 23:   2 lines after changes (not the whole file)\n 24: ${env.fence}\n 25: \n 26: DIFF ./file2.ts:\n 27: ${env.fence}diff\n 28:   2 line before changes (not the whole file)\n 29:   - deleted line\n 30:   - delete line 2\n 31:   + added line\n 32:   + added line 2\n 33:   2 lines after changes (not the whole file)\n 34: ${env.fence}\n 35: `\n 36: \n 37: $`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n 38: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do not generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do not emit the whole file content\n, deleted lines must exist in the original file (do not invent deleted lines)\n, added lines must not exist in the original file\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n`````diff\n  2 lines before changes (not the whole file)\n- deleted line\n- delete line 2\n+ added line\n+ added line 2\n  2 lines after changes (not the whole file)\n`````\n\nDIFF ./file2.ts:\n`````diff\n  2 line before changes (not the whole file)\n  - deleted line\n  - delete line 2\n  + added line\n  + added line 2\n  2 lines after changes (not the whole file)\n`````\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 2000\n\n```````````````markdown\nSOURCE:\n````` file=README.md\n---\ntitle: Python Email Validation Demo with GPTools\ndescription: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Argparse\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n`````\n\nYou are a helpful front matter generator. You are an SEO expert.\n\nGenerate DIFF for SOURCE front matter:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do not modify the markdown content after the front matter.\n\nIf no front matter is present, generate it.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nDIFF ./README.md:\n`````diff\n---\n- title: Python Email Validation Demo with GPTools\n- description: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\n- keywords: Python, Email Validation, GPTools, Regex, Argparse\n+ title: Python Email Validation Guide with GPTools\n+ description: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\n+ keywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n`````\n```````````````\n\n\n### Extracted Variables\n\n-   `DIFF ./README.md`\n`````\n---\n- title: Python Email Validation Demo with GPTools\n- description: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\n- keywords: Python, Email Validation, GPTools, Regex, Argparse\n+ title: Python Email Validation Guide with GPTools\n+ description: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\n+ keywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n`````\n\n","text":"DIFF ./README.md:\n`````diff\n---\n- title: Python Email Validation Demo with GPTools\n- description: A guide on improving a Python function for email validation using GPTools, including error handling, command line argument handling, and test cases.\n- keywords: Python, Email Validation, GPTools, Regex, Argparse\n+ title: Python Email Validation Guide with GPTools\n+ description: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\n+ keywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n`````"}}}
{"sha":"5906801c02980a31ec3bb5dd525187c482872c155ac9188d728f765cf349b334","key":{"template":{"id":"generate-python","title":"Generate python code"},"fragment":{"fullId":"problem.gpspec.md:0:0","hash":"c1d06f9df425c8b5"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/helloworld/email_recognizer.py":{"before":"import re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n","after":"import re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n"}},"trace":"\n# Prompt trace\n\n\n\n## Prompt template \"Generate python code\" (`generate-python`)\n\n```````````````js\n  1: gptool({\n  2:     title: \"Generate python code\",\n  3:     description: \"Given a task, generate python code.\",\n  4:     temperature: 0,\n  5:     categories: [\"hello world\"],\n  6: })\n  7: \n  8: def(\n  9:     \"CODE\",\n 10:     env.links.filter(\n 11:         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n 12:     )\n 13: )\n 14: def(\"TASK\", env.file)\n 15: \n 16: $`Generate python code for the task in TASK. Save code in CODE.`\n 17: $`If the CODE is already present, ensure that CODE matches the\n 18: description in TASK and make changes to CODE if it does not.\n 19: Do not modify TASK. Do not generate tests.`\n 20: \n 21: $`Follow the instructions in the Code Review section of TASK to generate CODE.`\n 22: \n```````````````\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n\n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.hello world** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nCODE:\n``` file=email_recognizer.py\nimport re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n```\n\nTASK:\n``` file=problem.gpspec.md\n# email address recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n-   [email_recognizer.py](email_recognizer.py)\n```\n\nGenerate python code for the task in TASK. Save code in CODE.\n\nIf the CODE is already present, ensure that CODE matches the\ndescription in TASK and make changes to CODE if it does not.\nDo not modify TASK. Do not generate tests.\n\nFollow the instructions in the Code Review section of TASK to generate CODE.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-OSAHFO`\n\n-   env.**file**\n```````````````js\n{ filename: \"problem.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email address recognizer\\n\\nWrite a function that takes a st\"... }\n```````````````\n\n-   env.**links**\n```````````````js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    pattern = r\\\"^[a-zA\"... } ]\n```````````````\n\n-   env.**parents**\n```````````````js\n[  ]\n```````````````\n\n-   env.**fence**\n```````````````\n```\n```````````````\n\n-   env.**markdownFence**\n```````````````\n`````\n```````````````\n\n-   env.**promptOptions**\n```````````````js\n{  }\n```````````````\n\n-   env.**vars**\n```````````````js\n{  }\n```````````````\n\n-   env.**templates**\n```````````````js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... } ]\n```````````````\n\n-   env.**template**\n```````````````js\n{ id: \"generate-python\",\ntitle: \"Generate python code\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Generate python code\\\",\\n    description:\"...,\nfilename: \"/workspaces/coarch/packages/helloworld/gptools/generate-pyth\"...,\ndescription: \"Given a task, generate python code.\",\ntemperature: 0,\ncategories: [ \"hello world\" ],\ninput: \".md\" }\n```````````````\n\n## System prompt\n###  template: `system`\n\n```````````````js\n  1: system({ title: \"System prompt\" })\n  2: $`You are concise. Answer in markdown.`\n```````````````\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.explanations`\n\n```````````````js\n  1: system({ title: \"Explain your answers\" })\n  2: $`When explaining answers, take a deep breath.`\n  3: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen explaining answers, take a deep breath.\n```````````````\n###  template: `system.files`\n\n```````````````js\n  1: system({\n  2:     title: \"File generation\",\n  3:     description: \"Teaches the file format supported by CoArch\",\n  4: })\n  5: \n  6: const folder =\n  7:     env.vars[\"system.multifile.outputFolder\"] || env.template.outputFolder\n  8: $`When generating or updating files you will use the following syntax:`\n  9: \n 10: def(\n 11:     `File ${folder || \".\"}/file1.ts`,\n 12:     `What goes in\\n${folder || \".\"}/file1.ts.`,\n 13:     \"typescript\"\n 14: )\n 15: def(\n 16:     `File ${folder || \".\"}/file1.py`,\n 17:     `What goes in\\n${folder || \".\"}/file1.py.`,\n 18:     \"python\"\n 19: )\n 20: def(\n 21:     `File /path_to_file/file2.md`,\n 22:     `What goes in\\n/path_to_file/file2.md.`,\n 23:     \"markdown\"\n 24: )\n 25: \n 26: $`Make sure to use precisely ${env.fence} to guard file code sections.`\n 27: $`Use full path of filename in code section header.`\n 28: if (folder) $`When generating new files, place files in folder \"${folder}\".`\n 29: $`If a file does not have changes, do not regenerate.`\n 30: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen generating or updating files you will use the following syntax:\n\nFile ./file1.ts:\n```\nWhat goes in\n./file1.ts.\n```\n\nFile ./file1.py:\n```\nWhat goes in\n./file1.py.\n```\n\nFile /path_to_file/file2.md:\n`````\nWhat goes in\n/path_to_file/file2.md.\n`````\n\nMake sure to use precisely ``` to guard file code sections.\n\nUse full path of filename in code section header.\n\nIf a file does not have changes, do not regenerate.\n```````````````\n###  template: `system.summary`\n\n```````````````js\n  1: system({\n  2:     title: \"Summarize\",\n  3:     description: \"Generate a summary of the changes\",\n  4: })\n  5: \n  6: $`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n  7: \n  8: def(`SUMMARY`, `This is a summary of the changes in files.`)\n  9: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 800\n\n```````````````markdown\nCODE:\n``` file=email_recognizer.py\nimport re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n```\n\nTASK:\n``` file=problem.gpspec.md\n# email address recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n-   [email_recognizer.py](email_recognizer.py)\n```\n\nGenerate python code for the task in TASK. Save code in CODE.\n\nIf the CODE is already present, ensure that CODE matches the\ndescription in TASK and make changes to CODE if it does not.\nDo not modify TASK. Do not generate tests.\n\nFollow the instructions in the Code Review section of TASK to generate CODE.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nFile ./email_recognizer.py:\n```python\nimport re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n```\n\nSUMMARY:\n```\nThe python file 'email_recognizer.py' was generated. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n```````````````\n\n\n### Extracted Variables\n\n-   `File ./email_recognizer.py`\n`````py\nimport re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n\n`````\n\n-   `SUMMARY`\n`````\nThe python file 'email_recognizer.py' was generated. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n\n`````\n\n","text":"File ./email_recognizer.py:\n```python\nimport re\n\ndef is_valid_email(email):\n    pattern = r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n```\n\nSUMMARY:\n```\nThe python file 'email_recognizer.py' was generated. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```","summary":"The python file 'email_recognizer.py' was generated. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n"}}}
{"sha":"5906801c02980a31ec3bb5dd525187c482872c155ac9188d728f765cf349b334","key":{"template":{"id":"generate-python","title":"Generate python code"},"fragment":{"fullId":"problem.gpspec.md:0:0","hash":"c1d06f9df425c8b5"}},"val":{"response":{"edits":[{"label":"Create /workspaces/coarch/packages/helloworld/email_recognizer.py","filename":"/workspaces/coarch/packages/helloworld/email_recognizer.py","type":"createfile","text":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n","overwrite":true}],"fileEdits":{"/workspaces/coarch/packages/helloworld/email_recognizer.py":{"before":null,"after":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n"}},"trace":"\n# Prompt trace\n\n\n\n## Prompt template \"Generate python code\" (`generate-python`)\n\n```````````````js\n  1: gptool({\n  2:     title: \"Generate python code\",\n  3:     description: \"Given a task, generate python code.\",\n  4:     temperature: 0,\n  5:     categories: [\"hello world\"],\n  6: })\n  7: \n  8: def(\n  9:     \"CODE\",\n 10:     env.links.filter(\n 11:         (f) => f.filename.endsWith(\".py\") && !f.filename.startsWith(\"test_\")\n 12:     )\n 13: )\n 14: def(\"TASK\", env.file)\n 15: \n 16: $`Generate python code for the task in TASK. Save code in CODE.`\n 17: $`If the CODE is already present, ensure that CODE matches the\n 18: description in TASK and make changes to CODE if it does not.\n 19: Do not modify TASK. Do not generate tests.`\n 20: \n 21: $`Follow the instructions in the Code Review section of TASK to generate CODE.`\n 22: \n```````````````\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n\n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.hello world** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nTASK:\n````` file=problem.gpspec.md\n# email address recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n-   [email_recognizer.py](email_recognizer.py)\n`````\n\nGenerate python code for the task in TASK. Save code in CODE.\n\nIf the CODE is already present, ensure that CODE matches the\ndescription in TASK and make changes to CODE if it does not.\nDo not modify TASK. Do not generate tests.\n\nFollow the instructions in the Code Review section of TASK to generate CODE.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-GMEDIS`\n\n-   env.**file**\n```````````````js\n{ filename: \"problem.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email address recognizer\\n\\nWrite a function that takes a st\"... }\n```````````````\n\n-   env.**links**\n```````````````js\n[  ]\n```````````````\n\n-   env.**parents**\n```````````````js\n[  ]\n```````````````\n\n-   env.**fence**\n```````````````\n```\n```````````````\n\n-   env.**markdownFence**\n```````````````\n`````\n```````````````\n\n-   env.**promptOptions**\n```````````````js\n{  }\n```````````````\n\n-   env.**vars**\n```````````````js\n{  }\n```````````````\n\n-   env.**templates**\n```````````````js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... } ]\n```````````````\n\n-   env.**template**\n```````````````js\n{ id: \"generate-python\",\ntitle: \"Generate python code\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Generate python code\\\",\\n    description:\"...,\nfilename: \"/workspaces/coarch/packages/helloworld/gptools/generate-pyth\"...,\ndescription: \"Given a task, generate python code.\",\ntemperature: 0,\ncategories: [ \"hello world\" ],\ninput: \".md\" }\n```````````````\n\n## System prompt\n###  template: `system`\n\n```````````````js\n  1: system({ title: \"System prompt\" })\n  2: $`You are concise. Answer in markdown.`\n```````````````\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.explanations`\n\n```````````````js\n  1: system({ title: \"Explain your answers\" })\n  2: $`When explaining answers, take a deep breath.`\n  3: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen explaining answers, take a deep breath.\n```````````````\n###  template: `system.files`\n\n```````````````js\n  1: system({\n  2:     title: \"File generation\",\n  3:     description: \"Teaches the file format supported by CoArch\",\n  4: })\n  5: \n  6: const folder =\n  7:     env.vars[\"system.multifile.outputFolder\"] || env.template.outputFolder\n  8: $`When generating or updating files you will use the following syntax:`\n  9: \n 10: def(\n 11:     `File ${folder || \".\"}/file1.ts`,\n 12:     `What goes in\\n${folder || \".\"}/file1.ts.`,\n 13:     \"typescript\"\n 14: )\n 15: def(\n 16:     `File ${folder || \".\"}/file1.py`,\n 17:     `What goes in\\n${folder || \".\"}/file1.py.`,\n 18:     \"python\"\n 19: )\n 20: def(\n 21:     `File /path_to_file/file2.md`,\n 22:     `What goes in\\n/path_to_file/file2.md.`,\n 23:     \"markdown\"\n 24: )\n 25: \n 26: $`Make sure to use precisely ${env.fence} to guard file code sections.`\n 27: $`Make sure to use precisely ${env.markdownFence} to guard file markdown sections.`\n 28: $`Use full path of filename in code section header.`\n 29: if (folder) $`When generating new files, place files in folder \"${folder}\".`\n 30: $`If a file does not have changes, do not regenerate.`\n 31: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen generating or updating files you will use the following syntax:\n\nFile ./file1.ts:\n```\nWhat goes in\n./file1.ts.\n```\n\nFile ./file1.py:\n```\nWhat goes in\n./file1.py.\n```\n\nFile /path_to_file/file2.md:\n`````\nWhat goes in\n/path_to_file/file2.md.\n`````\n\nMake sure to use precisely ``` to guard file code sections.\n\nMake sure to use precisely ````` to guard file markdown sections.\n\nUse full path of filename in code section header.\n\nIf a file does not have changes, do not regenerate.\n```````````````\n###  template: `system.summary`\n\n```````````````js\n  1: system({\n  2:     title: \"Summarize\",\n  3:     description: \"Generate a summary of the changes\",\n  4: })\n  5: \n  6: $`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n  7: \n  8: def(`SUMMARY`, `This is a summary of the changes in files.`)\n  9: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 800\n\n```````````````markdown\nTASK:\n````` file=problem.gpspec.md\n# email address recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n-   [email_recognizer.py](email_recognizer.py)\n`````\n\nGenerate python code for the task in TASK. Save code in CODE.\n\nIf the CODE is already present, ensure that CODE matches the\ndescription in TASK and make changes to CODE if it does not.\nDo not modify TASK. Do not generate tests.\n\nFollow the instructions in the Code Review section of TASK to generate CODE.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nFile ./email_recognizer.py:\n```python\nimport re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n```\n\nSUMMARY:\n```\nThe python file 'email_recognizer.py' was created. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```\n```````````````\n\n\n### Extracted Variables\n\n-   `File ./email_recognizer.py`\n`````py\nimport re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n\n`````\n\n-   `SUMMARY`\n`````\nThe python file 'email_recognizer.py' was created. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n\n`````\n\n","text":"File ./email_recognizer.py:\n```python\nimport re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n```\n\nSUMMARY:\n```\nThe python file 'email_recognizer.py' was created. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n```","summary":"The python file 'email_recognizer.py' was created. It contains a function 'is_valid_email' that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n"}}}
{"sha":"a7bc545aff6c39ba8bfe2f31a973fd285c03a6a7390b677381b6b2b0bd12763f","key":{"template":{"id":"front-matter","title":"SEO front matter"},"fragment":{"fullId":"README.md.gpspec.md:0:0","hash":"f853854a0efa414d"}},"val":{"response":{"edits":[{"label":"Update /workspaces/coarch/packages/helloworld/README.md","filename":"/workspaces/coarch/packages/helloworld/README.md","type":"replace","range":[[0,0],[64,0]],"text":"---\ntitle: Python Email Validation with GPTools\ndescription: A comprehensive guide on enhancing Python functions for email validation using GPTools. Includes error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n"}],"fileEdits":{"/workspaces/coarch/packages/helloworld/README.md":{"before":"---\ntitle: Python Email Validation Guide with GPTools\ndescription: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n","after":"---\ntitle: Python Email Validation with GPTools\ndescription: A comprehensive guide on enhancing Python functions for email validation using GPTools. Includes error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n"}},"trace":"\n# Prompt trace\n\n\n\n## Prompt template \"SEO front matter\" (`front-matter`)\n\n```````````````js\n  1: gptool({\n  2:     title: \"SEO front matter\",\n  3:     description: \"Update or generate SEO-optimized front matter for a markdown file.\",\n  4:     categories: [\"markdown\"],\n  5:     system: [\"system\", \"system.files\"],\n  6:     maxTokens: 2000,\n  7:     temperature: 0,\n  8: })\n  9: \n 10: def(\"FILE\", env.links.filter(f => f.filename.endsWith(\".md\")))\n 11: \n 12: $`\n 13: You are a search engine optimization expert at creating front matter for markdown document.\n 14: \n 15: Update or generate front matter in FILE:\n 16: - Update fields title, description and keywords as needed\n 17: - use yaml format, do not use quotes\n 18: - only 5 keywords or less\n 19: - optimize for search engine optimization.\n 20: - Do not modify the markdown content after the front matter\n 21: \n 22: If no front matter is present, generate it.\n 23: `\n 24: \n```````````````\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n\n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.markdown** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nFILE:\n````` file=README.md\n---\ntitle: Python Email Validation Guide with GPTools\ndescription: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do not modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-CPLRQA`\n\n-   env.**file**\n```````````````js\n{ filename: \"README.md.gpspec.md\",\nlabel: \"current\",\ncontent: \"# README.md\\n\\n-   [README.md](./README.md)\\n\" }\n```````````````\n\n-   env.**links**\n```````````````js\n[ { label: \"README.md\",\n  filename: \"README.md\",\n  content: \"---\\ntitle: Python Email Validation Guide with GPTools\\ndescri\"... } ]\n```````````````\n\n-   env.**parents**\n```````````````js\n[  ]\n```````````````\n\n-   env.**fence**\n```````````````\n```\n```````````````\n\n-   env.**markdownFence**\n```````````````\n`````\n```````````````\n\n-   env.**promptOptions**\n```````````````js\n{  }\n```````````````\n\n-   env.**vars**\n```````````````js\n{  }\n```````````````\n\n-   env.**templates**\n```````````````js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... } ]\n```````````````\n\n-   env.**template**\n```````````````js\n{ id: \"front-matter\",\ntitle: \"SEO front matter\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"SEO front matter\\\",\\n    description: \\\"Up\"...,\ndescription: \"Update or generate SEO-optimized front matter for a markdown\"...,\ncategories: [ \"markdown\" ],\nsystem: [ \"system\",\n  \"system.files\" ],\nmaxTokens: 2000,\ntemperature: 0,\ninput: \".md\" }\n```````````````\n\n## System prompt\n###  template: `system`\n\n```````````````js\n  1: system({ title: \"System prompt\" })\n  2: $`You are concise. Answer in markdown.`\n```````````````\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.files`\n\n```````````````js\n  1: system({\n  2:     title: \"File generation\",\n  3:     description: \"Teaches the file format supported by CoArch\",\n  4: })\n  5: \n  6: const folder =\n  7:     env.vars[\"system.multifile.outputFolder\"] || env.template.outputFolder\n  8: $`When generating or updating files you will use the following syntax:`\n  9: \n 10: def(\n 11:     `File ${folder || \".\"}/file1.ts`,\n 12:     `What goes in\\n${folder || \".\"}/file1.ts.`,\n 13:     \"typescript\"\n 14: )\n 15: def(\n 16:     `File ${folder || \".\"}/file1.py`,\n 17:     `What goes in\\n${folder || \".\"}/file1.py.`,\n 18:     \"python\"\n 19: )\n 20: def(\n 21:     `File /path_to_file/file2.md`,\n 22:     `What goes in\\n/path_to_file/file2.md.`,\n 23:     \"markdown\"\n 24: )\n 25: \n 26: $`Make sure to use precisely ${env.fence} to guard file code sections.`\n 27: $`Make sure to use precisely ${env.markdownFence} to guard file markdown sections.`\n 28: $`Use full path of filename in code section header.`\n 29: if (folder) $`When generating new files, place files in folder \"${folder}\".`\n 30: $`If a file does not have changes, do not regenerate.`\n 31: \n```````````````\n#### Expanded system prompt\n```````````````markdown\nWhen generating or updating files you will use the following syntax:\n\nFile ./file1.ts:\n```\nWhat goes in\n./file1.ts.\n```\n\nFile ./file1.py:\n```\nWhat goes in\n./file1.py.\n```\n\nFile /path_to_file/file2.md:\n`````\nWhat goes in\n/path_to_file/file2.md.\n`````\n\nMake sure to use precisely ``` to guard file code sections.\n\nMake sure to use precisely ````` to guard file markdown sections.\n\nUse full path of filename in code section header.\n\nIf a file does not have changes, do not regenerate.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 2000\n\n```````````````markdown\nFILE:\n````` file=README.md\n---\ntitle: Python Email Validation Guide with GPTools\ndescription: Learn how to enhance a Python function for email validation using GPTools. This guide covers error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n```\n\n\n### Extracted Variables\n\n-   `*`\n```\n\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n\"\"\"\nCheck if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\nparser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\nparser.add_argument(\"email\", help=\"The email address to be checked.\")\nargs = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif **name** == \"**main**\":\nmain()\ndef test_is_valid_email():\nassert is_valid_email(\"test@example.com\") == True\nassert is_valid_email(\"test+123@example.co.uk\") == True\nassert is_valid_email(\"test@subdomain.example.com\") == True\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@example\") == False\nassert is_valid_email(\"test@.com\") == False\nassert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n\n```\n\n-   remaining\n```\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\nTest cases:\n`````\n\nYou are a search engine optimization expert at creating front matter for markdown document.\n\nUpdate or generate front matter in FILE:\n- Update fields title, description and keywords as needed\n- use yaml format, do not use quotes\n- only 5 keywords or less\n- optimize for search engine optimization.\n- Do not modify the markdown content after the front matter\n\nIf no front matter is present, generate it.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nFile README.md:\n`````markdown\n---\ntitle: Python Email Validation with GPTools\ndescription: A comprehensive guide on enhancing Python functions for email validation using GPTools. Includes error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n`````\n```````````````\n\n\n### Extracted Variables\n\n-   `File README.md`\n`````md\n---\ntitle: Python Email Validation with GPTools\ndescription: A comprehensive guide on enhancing Python functions for email validation using GPTools. Includes error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n\n`````\n\n","text":"File README.md:\n`````markdown\n---\ntitle: Python Email Validation with GPTools\ndescription: A comprehensive guide on enhancing Python functions for email validation using GPTools. Includes error handling, command line argument handling, and test cases.\nkeywords: Python, Email Validation, GPTools, Regex, Command Line Arguments\n---\n\n# Hello world GPTools\n\nThis sample contains a few gptools and started gpspec files to get started.\n\n## Python generation demo\n\n1. Add a docstring to the `is_valid_email` function to explain its purpose and parameters.\n2. Use a compiled regex pattern for better performance.\n3. Use argparse for better command line argument handling and help messages.\n4. Add error handling for invalid input.\n5. Add test cases to ensure the function works as expected.\n\nHere's the improved code:\n\n```python\nimport re\nimport sys\nimport argparse\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Check if the given string is a valid email address.\n\n    :param email: The string to be checked.\n    :return: True if the string is a valid email address, False otherwise.\n    \"\"\"\n    # Regular expression for validating an email\n    email_regex = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    return bool(email_regex.match(email))\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Check if a given string is a valid email address.\")\n    parser.add_argument(\"email\", help=\"The email address to be checked.\")\n    args = parser.parse_args()\n\n    try:\n        print(is_valid_email(args.email))\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n\n```python\ndef test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"test+123@example.co.uk\") == True\n    assert is_valid_email(\"test@subdomain.example.com\") == True\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@example\") == False\n    assert is_valid_email(\"test@.com\") == False\n    assert is_valid_email(\"test@.com\") == False\n\ntest_is_valid_email()\n```\n`````\n"}}}
{"sha":"86a71be8ecf34689d4cc1988cf93027b572e4b3cb83336e02dd9e4e99bdffdec","key":{"template":{"id":"code-optimizer","title":"Code Optimizer"},"fragment":{"fullId":"email_recognizer.py.gpspec.md:0:0","hash":"1f2e6fc915fb612f"}},"val":{"response":{"edits":[],"fileEdits":{},"trace":"\n# Prompt trace\n\n\n\n## GPTool \"Code Optimizer\" (`code-optimizer`)\n\n```js\ngptool({\n    title: \"Code Optimizer\",\n    description:\n        \"Optimize code to run faster, modified from https://twitter.com/mattshumer_/status/1719403205950349588.\",\n    maxTokens: 2000,\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\"],\n})\n\n// Modified from https://twitter.com/mattshumer_/status/1719403205950349588?s=46\ndef(\"FILE\", env.links, { lineNumbers: true })\n\n$`\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n`\n```\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.samples** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-JZDUDS`\n\n-   env.**file**\n```js\n{ filename: \"email_recognizer.py.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email_recognizer.py\\n\\n-   [email_recognizer.py](./email_rec\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    if re.fullmatch(r\\\"\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n```\n```\n```\n\n-   env.**markdownFence**\n```\n`````\n```\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"code-optimizer\",\ntitle: \"Code Optimizer\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Code Optimizer\\\",\\n    description:\\n     \"...,\ndescription: \"Optimize code to run faster, modified from https://twitter.c\"...,\nmaxTokens: 2000,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\" ],\ninput: \".md\" }\n```\n\n## System prompt\n###  template: `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do not generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do not emit the whole file content\n, deleted lines must exist in the original file (do not invent deleted lines)\n, added lines must not exist in the original file\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n  <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n  <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### Expanded system prompt\n```````````````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do not generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do not emit the whole file content\n, deleted lines must exist in the original file (do not invent deleted lines)\n, added lines must not exist in the original file\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n  <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n  <2 lines before changes (not the whole file)>\n- <deleted line>\n- <delete line 2>\n+ <added line>\n+ <added line 2>\n  <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: 0.2\n-  max tokens: 2000\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nThe provided code is relatively simple and does not contain any obvious performance bottlenecks. It's a single function that validates an email address using a regular expression. The performance of this function will primarily depend on the complexity of the regular expression and the length of the input string.\n\nHowever, the `re.fullmatch()` function is called every time the function is invoked. Compiling the regular expression once and reusing the compiled version could slightly improve the performance, especially if the function is called multiple times.\n\nHere is the updated code with the regular expression compiled:\n\n```python\nimport re\n\nemail_regex = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n\ndef is_valid_email(email):\n    if email_regex.fullmatch(email):\n        return True\n    else:\n        return False\n```\n\nThe DIFF format for the changes would be:\n\nDIFF ./email_recognizer.py:\n```diff\n  import re\n+ email_regex = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n  \n  def is_valid_email(email):\n-     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n+     if email_regex.fullmatch(email):\n          return True\n      else:\n          return False\n```\n\nThis change should not introduce any new issues. The regular expression is compiled once and reused, which should slightly improve the performance if the function is called multiple times. However, the performance improvement might not be noticeable unless the function is called with very long strings or called very frequently.\n```````````````\n\n\n### Extracted Variables\n\n-   `*`\n`````\n\nThe DIFF format for the changes would be:\n\nDIFF ./email_recognizer.py:\n```diff\n  import re\n+ email_regex = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n  \n  def is_valid_email(email):\n-     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n+     if email_regex.fullmatch(email):\n          return True\n      else:\n          return False\n\n`````\n\n","text":"The provided code is relatively simple and does not contain any obvious performance bottlenecks. It's a single function that validates an email address using a regular expression. The performance of this function will primarily depend on the complexity of the regular expression and the length of the input string.\n\nHowever, the `re.fullmatch()` function is called every time the function is invoked. Compiling the regular expression once and reusing the compiled version could slightly improve the performance, especially if the function is called multiple times.\n\nHere is the updated code with the regular expression compiled:\n\n```python\nimport re\n\nemail_regex = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n\ndef is_valid_email(email):\n    if email_regex.fullmatch(email):\n        return True\n    else:\n        return False\n```\n\nThe DIFF format for the changes would be:\n\nDIFF ./email_recognizer.py:\n```diff\n  import re\n+ email_regex = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n  \n  def is_valid_email(email):\n-     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n+     if email_regex.fullmatch(email):\n          return True\n      else:\n          return False\n```\n\nThis change should not introduce any new issues. The regular expression is compiled once and reused, which should slightly improve the performance if the function is called multiple times. However, the performance improvement might not be noticeable unless the function is called with very long strings or called very frequently."}}}
{"sha":"86a71be8ecf34689d4cc1988cf93027b572e4b3cb83336e02dd9e4e99bdffdec","key":{"template":{"id":"code-optimizer","title":"Code Optimizer"},"fragment":{"fullId":"email_recognizer.py.gpspec.md:0:0","hash":"1f2e6fc915fb612f"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/helloworld/email_recognizer.py":{"before":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n","after":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n"}},"trace":"\n# Prompt trace\n\n\n\n## GPTool \"Code Optimizer\" (`code-optimizer`)\n\n```js\ngptool({\n    title: \"Code Optimizer\",\n    description:\n        \"Optimize code to run faster, modified from https://twitter.com/mattshumer_/status/1719403205950349588.\",\n    maxTokens: 2000,\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\"],\n})\n\n// Modified from https://twitter.com/mattshumer_/status/1719403205950349588?s=46\ndef(\"FILE\", env.links, { lineNumbers: true })\n\n$`\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n`\n```\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.samples** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-XTFIHN`\n\n-   env.**file**\n```js\n{ filename: \"email_recognizer.py.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email_recognizer.py\\n\\n-   [email_recognizer.py](./email_rec\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    if re.fullmatch(r\\\"\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n```````````````markdown\n```\n```````````````\n\n-   env.**markdownFence**\n```````````````markdown\n`````\n```````````````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"code-optimizer\",\ntitle: \"Code Optimizer\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Code Optimizer\\\",\\n    description:\\n     \"...,\ndescription: \"Optimize code to run faster, modified from https://twitter.c\"...,\nmaxTokens: 2000,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\" ],\ninput: \".md\" }\n```\n\n## System prompt\n###  template: `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n[line number]  <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[line number]   <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### Expanded system prompt\n```````````````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n[line number]  <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[line number]   <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: 0.2\n-  max tokens: 2000\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nThe given code is a simple email validation function using regular expressions in Python. It's already quite efficient, but there's a minor optimization that can be made.\n\nThe `re.fullmatch()` function is used to check if the entire string matches the regular expression. However, this function can be slightly slow because it checks the entire string from start to end. \n\nA faster approach would be to use the `re.match()` function instead, which stops as soon as it finds a match. This can be faster, especially for long strings that don't match the pattern.\n\nHere's the diff and the optimized code:\n\nDIFF ./email_recognizer.py:\n```diff\n[3] def is_valid_email(email):\n[4] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[4] +    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nOptimized code:\n```python\nimport re\n\ndef is_valid_email(email):\n    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n        return True\n    else:\n        return False\n```\n\nThis code should work just as well as the original, but with a minor speed improvement. However, the difference in speed will likely only be noticeable for very long strings. For typical email addresses, the difference will be negligible.\n```````````````\n\n\n### Extracted Variables\n\n-   `DIFF ./email_recognizer.py`\n`````\n[3] def is_valid_email(email):\n[4] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[4] +    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n\n`````\n\n-   `Optimized code`\n`````\nimport re\n\ndef is_valid_email(email):\n    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n        return True\n    else:\n        return False\n\n`````\n\n","text":"The given code is a simple email validation function using regular expressions in Python. It's already quite efficient, but there's a minor optimization that can be made.\n\nThe `re.fullmatch()` function is used to check if the entire string matches the regular expression. However, this function can be slightly slow because it checks the entire string from start to end. \n\nA faster approach would be to use the `re.match()` function instead, which stops as soon as it finds a match. This can be faster, especially for long strings that don't match the pattern.\n\nHere's the diff and the optimized code:\n\nDIFF ./email_recognizer.py:\n```diff\n[3] def is_valid_email(email):\n[4] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[4] +    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nOptimized code:\n```python\nimport re\n\ndef is_valid_email(email):\n    if re.match(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\", email):\n        return True\n    else:\n        return False\n```\n\nThis code should work just as well as the original, but with a minor speed improvement. However, the difference in speed will likely only be noticeable for very long strings. For typical email addresses, the difference will be negligible."}}}
{"sha":"86a71be8ecf34689d4cc1988cf93027b572e4b3cb83336e02dd9e4e99bdffdec","key":{"template":{"id":"code-optimizer","title":"Code Optimizer"},"fragment":{"fullId":"email_recognizer.py.gpspec.md:0:0","hash":"1f2e6fc915fb612f"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/helloworld/email_recognizer.py":{"before":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n","after":"import re\n\ndef is_valid_email(email):\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n"}},"trace":"\n# Prompt trace\n\n\n\n## GPTool \"Code Optimizer\" (`code-optimizer`)\n\n```js\ngptool({\n    title: \"Code Optimizer\",\n    description:\n        \"Optimize code to run faster, modified from https://twitter.com/mattshumer_/status/1719403205950349588.\",\n    maxTokens: 2000,\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\"],\n})\n\n// Modified from https://twitter.com/mattshumer_/status/1719403205950349588?s=46\ndef(\"FILE\", env.links, { lineNumbers: true })\n\n$`\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n`\n```\n\n\n\n## Inline prompts\n\nAdded as comment at the end of a fragment: \n```markdown\nLorem ipsum...\n\n<!-- @prompt.NAME \nYou are concise.\n!-->\n```\n        \n\n-   **@prompt** missing\n-   **@prompt.samples** missing\n\n\n## console output\n> tip: use `console.log()` from gptool.js files\n## Expanded prompt\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## Variables\nVariables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-OFGUVW`\n\n-   env.**file**\n```js\n{ filename: \"email_recognizer.py.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email_recognizer.py\\n\\n-   [email_recognizer.py](./email_rec\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    if re.fullmatch(r\\\"\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n```````````````markdown\n```\n```````````````\n\n-   env.**markdownFence**\n```````````````markdown\n`````\n```````````````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"code-optimizer\",\ntitle: \"Code Optimizer\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Code Optimizer\\\",\\n    description:\\n     \"...,\ndescription: \"Optimize code to run faster, modified from https://twitter.c\"...,\nmaxTokens: 2000,\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\" ],\ninput: \".md\" }\n```\n\n## System prompt\n###  template: `system`\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### Expanded system prompt\n```````````````markdown\nYou are concise. Answer in markdown.\n```````````````\n###  template: `system.diff`\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from delete lines and existing lines\n, do NOT emit line numbers for added lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n${env.fence}diff\n[line number]  <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[line number]   <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### Expanded system prompt\n```````````````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, do not add line numbers\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit line numbers from delete lines and existing lines\n, do NOT emit line numbers for added lines\n, keep the diffs as small as possible:\n\nDIFF ./file.ts:\n```diff\n[line number]  <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[line number]   <2 lines before changes (not the whole file)>\n[line number] - <deleted line>\n[line number] - <delete line 2>\n[line number] + <added line>\n[line number] + <added line 2>\n[line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n```````````````\n\n\n## Final prompt\n\n-  model: `gpt-4`\n-  temperature: 0.2\n-  max tokens: 2000\n\n```````````````markdown\nFILE:\n``` file=email_recognizer.py\n[1] import re\n[2] \n[3] def is_valid_email(email):\n[4]     if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[5]         return True\n[6]     else:\n[7]         return False\n```\n\nYou are a world expert in making code run faster. You use any resource you can to do so.\n\nGiven some code in FILE files, identify how long it might take to run.\n\nAfter that, identify which parts are key candidates to speed up.\n\nAfter that, order the candidates by ranking.\n\nTake the top-ranked candidate and explain in more detail how to rewrite the code to be faster using a DIFF format. \nThen, rewrite the actual code. \nAfter you've done that, determine if there are issues with the new code you wrote. \nIf so, move on. Otherwise, rewrite the code again to fix them.\n\nUpdate FILE files with all of the speed improvements.\n```````````````\n\n\n## AI Output\n\n\n```````````````markdown\nThe given code is relatively simple and doesn't have any obvious bottlenecks. However, the regular expression compilation in the `is_valid_email` function could be optimized. Regular expressions are compiled into byte code which is then executed by the regular expression engine. This compilation process can be slow, so if the same regular expression is used multiple times, it's more efficient to compile it once and reuse the compiled version.\n\nHere's the ranking of the optimization candidates:\n1. Regular expression compilation in `is_valid_email` function.\n\nLet's rewrite the code to compile the regular expression only once:\n\nDIFF ./email_recognizer.py:\n```diff\n[1] import re\n[2] \n[3] + EMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n[4] \n[5] def is_valid_email(email):\n[6] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[7] +    if EMAIL_REGEX.fullmatch(email):\n[8]         return True\n[9]     else:\n[10]        return False\n```\n\nRewritten code:\n```python\nimport re\n\nEMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n\ndef is_valid_email(email):\n    if EMAIL_REGEX.fullmatch(email):\n        return True\n    else:\n        return False\n```\n\nThere are no apparent issues with the new code. The regular expression is now compiled only once, which should make the `is_valid_email` function faster when it's called multiple times.\n```````````````\n\n\n### Extracted Variables\n\n-   `DIFF ./email_recognizer.py`\n`````\n[1] import re\n[2] \n[3] + EMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n[4] \n[5] def is_valid_email(email):\n[6] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[7] +    if EMAIL_REGEX.fullmatch(email):\n[8]         return True\n[9]     else:\n[10]        return False\n\n`````\n\n-   `Rewritten code`\n`````\nimport re\n\nEMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n\ndef is_valid_email(email):\n    if EMAIL_REGEX.fullmatch(email):\n        return True\n    else:\n        return False\n\n`````\n\n","text":"The given code is relatively simple and doesn't have any obvious bottlenecks. However, the regular expression compilation in the `is_valid_email` function could be optimized. Regular expressions are compiled into byte code which is then executed by the regular expression engine. This compilation process can be slow, so if the same regular expression is used multiple times, it's more efficient to compile it once and reuse the compiled version.\n\nHere's the ranking of the optimization candidates:\n1. Regular expression compilation in `is_valid_email` function.\n\nLet's rewrite the code to compile the regular expression only once:\n\nDIFF ./email_recognizer.py:\n```diff\n[1] import re\n[2] \n[3] + EMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n[4] \n[5] def is_valid_email(email):\n[6] -    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n[7] +    if EMAIL_REGEX.fullmatch(email):\n[8]         return True\n[9]     else:\n[10]        return False\n```\n\nRewritten code:\n```python\nimport re\n\nEMAIL_REGEX = re.compile(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\")\n\ndef is_valid_email(email):\n    if EMAIL_REGEX.fullmatch(email):\n        return True\n    else:\n        return False\n```\n\nThere are no apparent issues with the new code. The regular expression is now compiled only once, which should make the `is_valid_email` function faster when it's called multiple times."}}}
{"sha":"36a0b37e27efc86cd3114cab1b7e1c270ac9a0e4d9f4cdab9b9695013ebc22c3","key":{"template":{"id":"todo","title":"TODOs"},"fragment":{"fullId":"email_recognizer.py.gpspec.md:0:0","hash":"1f2e6fc915fb612f"}},"val":{"response":{"edits":[],"fileEdits":{"/workspaces/coarch/packages/helloworld/email_recognizer.py":{"before":"import re\n\ndef is_valid_email(email):\n    # TODO: use builtin libraries\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n","after":"import re\n\ndef is_valid_email(email):\n    # TODO: use builtin libraries\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n"}},"trace":"\n# `todo` trace\n\n\n\n\n\n<details id=\"console-output\"><summary>console output</summary>\n\n> tip: use `console.log()` from gptool.js files\n\n</details>\n\n\n<details id=\"variables\"><summary>variables</summary>\n\n> Variables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-OEQPBM`\n\n-   env.**file**\n```js\n{ filename: \"email_recognizer.py.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email_recognizer.py\\n\\n-   [email_recognizer.py](./email_rec\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    # TODO: use builti\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n``````markdown\n```\n``````\n\n-   env.**markdownFence**\n``````markdown\n`````\n``````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"code-xray\",\n  title: \"Code XRay\",\n  description: \"Given a source file in a programming language, extract the s\"... },\n{ id: \"gptool-meta\",\n  title: \"GPTool metadata generator\",\n  description: \"Generates metadata for GPTools\" },\n{ id: \"slides\",\n  title: \"Generate Slides\",\n  description: \"Generate a slidedeck in markdown. Install extension 'vscode-\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"todo\",\n  title: \"TODOs\",\n  description: \"Try to implement TODOs found in source code.\" },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"todo\",\ntitle: \"TODOs\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"TODOs\\\",\\n    description: \\\"Try to implem\"...,\ndescription: \"Try to implement TODOs found in source code.\",\ncategories: [ \"samples\" ],\nsystem: [ \"system\",\n  \"system.diff\" ],\ntemperature: 0,\ninput: \".md\" }\n```\n\n\n\n</details>\n\n\n<details id=\"system-gptools\"><summary>system gptools</summary>\n\n###  `system` source\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### expanded\n``````markdown\nYou are concise. Answer in markdown.\n``````\n###  `system.diff` source\n\n```js\nsystem({ title: \"Diff generation\", description: \"Teaches the diff file format supported by GPTools\" })\n\n$`The DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit original line numbers from existing lines and deleted lines\n, do NOT emit line numbers for added lines\n, keep the diffs AS SMALL AS POSSIBLE:\n\nDIFF ./file.ts:\n${env.fence}diff\n[original line number]  <2 lines before changes (not the whole file)>\n- [original line number] <deleted line>\n- [original line number] <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n\nDIFF ./file2.ts:\n${env.fence}diff\n[original line number]   <2 lines before changes (not the whole file)>\n- [original line number] <deleted line>\n- [original line number] <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n${env.fence}\n`\n\n$`Do not generate anything else than DIFF sections. Use one DIFF section per change.`\n```\n#### expanded\n``````markdown\nThe DIFF format should be used to generate diff changes on files: added lines start with +\n, deleted lines start with -\n, preserve indentation\n, use relative file path name\n, only generate diff for files that have changes\n, do NOT generate diff for files that have no changes\n, only emit a couple unmodified lines before and after the changes\n, do NOT emit the whole file content\n, deleted lines MUST exist in the original file (do not invent deleted lines)\n, added lines MUST not exist in the original file\n, emit original line numbers from existing lines and deleted lines\n, do NOT emit line numbers for added lines\n, keep the diffs AS SMALL AS POSSIBLE:\n\nDIFF ./file.ts:\n```diff\n[original line number]  <2 lines before changes (not the whole file)>\n- [original line number] <deleted line>\n- [original line number] <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDIFF ./file2.ts:\n```diff\n[original line number]   <2 lines before changes (not the whole file)>\n- [original line number] <deleted line>\n- [original line number] <delete line 2>\n+ <added line>\n+ <added line 2>\n[original line number]   <2 lines after changes (not the whole file)>\n```\n\nDo not generate anything else than DIFF sections. Use one DIFF section per change.\n``````\n\n\n</details>\n\n\n<details id=\"gptool-source\"><summary>gptool source</summary>\n\n\n```js\ngptool({\n    title: \"TODOs\",\n    description: \"Try to implement TODOs found in source code.\",\n    categories: [\"samples\"],\n    system: [\"system\", \"system.diff\"],\n    temperature: 0,\n})\n\ndef(\"SPEC\", env.file)\ndef(\"CODE\", env.links)\n\n$`In CODE, when you encounter a comment starting by \"TODO\", \ngenerate code for the TODO comment in a DIFF format and use the information in SPEC.\nDo not regenerate unmodified files.\nUse recommendations from SPEC.\n`\n```\n\n\n</details>\n\n\n<details id=\"expanded-prompt\"><summary>expanded prompt</summary>\n\n-  model: `gpt-4`\n-  temperature: \n-  max tokens: 800\n\n``````markdown\nSPEC:\n````` file=email_recognizer.py.gpspec.md\n# email_recognizer.py\n\n-   [email_recognizer.py](./email_recognizer.py)\n`````\n\nCODE:\n``` file=email_recognizer.py\nimport re\n\ndef is_valid_email(email):\n    # TODO: use builtin libraries\n    if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n        return True\n    else:\n        return False\n```\n\nIn CODE, when you encounter a comment starting by \"TODO\", \ngenerate code for the TODO comment in a DIFF format and use the information in SPEC.\nDo not regenerate unmodified files.\nUse recommendations from SPEC.\n``````\n\n\n</details>\n\n\n<details id=\"LLM-response\"><summary>LLM response</summary>\n\n\n``````markdown\nDIFF ./email_recognizer.py:\n```diff\n3   def is_valid_email(email):\n4   - # TODO: use builtin libraries\n5   - if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n6   + from validate_email import validate_email\n7   + if validate_email(email):\n8       return True\n9   else:\n10      return False\n```\n``````\n\n\n</details>\n\n\n<details id=\"code-regions\"><summary>code regions</summary>\n\n-   `DIFF ./email_recognizer.py`\n`````\n3   def is_valid_email(email):\n4   - # TODO: use builtin libraries\n5   - if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n6   + from validate_email import validate_email\n7   + if validate_email(email):\n8       return True\n9   else:\n10      return False\n\n`````\n\n\n</details>\n\n\n### Error applying patch\n\n\n``````markdown\nmissing line number\n``````\n","text":"DIFF ./email_recognizer.py:\n```diff\n3   def is_valid_email(email):\n4   - # TODO: use builtin libraries\n5   - if re.fullmatch(r\"[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\", email):\n6   + from validate_email import validate_email\n7   + if validate_email(email):\n8       return True\n9   else:\n10      return False\n```"}}}
{"sha":"da187fd1516c12341e907614f781d4d557c9f1723ef0767fa449ac6b927c7d7d","key":{"template":{"id":"bdd-feature","title":"Generate BDD scenarios"},"fragment":{"fullId":"problem.gpspec.md:0:0","hash":"c1d06f9df425c8b5"}},"val":{"response":{"edits":[{"label":"Create /workspaces/coarch/packages/helloworld/problem.feature","filename":"/workspaces/coarch/packages/helloworld/problem.feature","type":"createfile","text":"Feature: Email Address Recognizer\n  The function should take a string argument and return true if the whole string is a valid email address, false otherwise.\n\n  Scenario: Valid Email Address\n    Given a string \"test@example.com\"\n    When the function is called\n    Then it should return true\n\n  Scenario: Invalid Email Address\n    Given a string \"testexample.com\"\n    When the function is called\n    Then it should return false\n\n  Scenario: Empty String\n    Given a string \"\"\n    When the function is called\n    Then it should return false\n","overwrite":true},{"label":"Generate BDD scenarios","filename":"/workspaces/coarch/packages/helloworld/problem.gpspec.md","type":"insert","pos":[3,46],"text":"\n-   [problem.feature](problem.feature)"}],"fileEdits":{"/workspaces/coarch/packages/helloworld/problem.feature":{"before":null,"after":"Feature: Email Address Recognizer\n  The function should take a string argument and return true if the whole string is a valid email address, false otherwise.\n\n  Scenario: Valid Email Address\n    Given a string \"test@example.com\"\n    When the function is called\n    Then it should return true\n\n  Scenario: Invalid Email Address\n    Given a string \"testexample.com\"\n    When the function is called\n    Then it should return false\n\n  Scenario: Empty String\n    Given a string \"\"\n    When the function is called\n    Then it should return false\n"}},"trace":"\n# `bdd-feature` trace\n\n\n\n\n\n<details id=\"console-output\"><summary>console output</summary>\n\n> tip: use `console.log()` from gptool.js files\n\n</details>\n\n\n<details id=\"variables\"><summary>variables</summary>\n\n> Variables are referenced through `env.NAME` in prompts.\n\n-   env.**error**: `ERROR-XCQDGX`\n\n-   env.**file**\n```js\n{ filename: \"problem.gpspec.md\",\nlabel: \"current\",\ncontent: \"# email address recognizer\\n\\nWrite a function that takes a st\"... }\n```\n\n-   env.**links**\n```js\n[ { label: \"email_recognizer.py\",\n  filename: \"email_recognizer.py\",\n  content: \"import re\\n\\ndef is_valid_email(email):\\n    # TODO: use builti\"... } ]\n```\n\n-   env.**parents**\n```js\n[  ]\n```\n\n-   env.**fence**\n``````markdown\n```\n``````\n\n-   env.**markdownFence**\n``````markdown\n`````\n``````\n\n-   env.**promptOptions**\n```js\n{  }\n```\n\n-   env.**vars**\n```js\n{  }\n```\n\n-   env.**templates**\n```js\n[ { id: \"generate-python\",\n  title: \"Generate python code\",\n  description: \"Given a task, generate python code.\" },\n{ id: \"generate-python-tests\",\n  title: \"Generate python tests\",\n  description: \"Given a task and code, generate tests\" },\n{ id: \"code-optimizer\",\n  title: \"Code Optimizer\",\n  description: \"Optimize code to run faster, modified from https://twitter.c\"... },\n{ id: \"code-xray\",\n  title: \"Code XRay\",\n  description: \"Given a source file in a programming language, extract the s\"... },\n{ id: \"gptool-meta\",\n  title: \"GPTool metadata generator\",\n  description: \"Generates metadata for GPTools\" },\n{ id: \"bdd-feature\",\n  title: \"Generate BDD scenarios\",\n  description: \"Generate a Gherkin .feature file from the node and children.\" },\n{ id: \"slides\",\n  title: \"Generate Slides\",\n  description: \"Generate a slidedeck in markdown. Install extension 'vscode-\"... },\n{ id: \"core.default\",\n  title: \"Run gpspec directly\",\n  description: \"This is the default gptool that assumes the gpspec contains \"... },\n{ id: \"front-matter\",\n  title: \"SEO front matter\",\n  description: \"Update or generate SEO-optimized front matter for a markdown\"... },\n{ id: \"todo\",\n  title: \"TODOs\",\n  description: \"Try to implement TODOs found in source code.\" },\n{ id: \"peer-review\",\n  title: \"peer review\",\n  description: \"An expert academic is reviewing your submission.\" } ]\n```\n\n-   env.**template**\n```js\n{ id: \"bdd-feature\",\ntitle: \"Generate BDD scenarios\",\ntext: \"<nothing yet>\",\njsSource: \"gptool({\\n    title: \\\"Generate BDD scenarios\\\",\\n    descriptio\"...,\ndescription: \"Generate a Gherkin .feature file from the node and children.\",\ncategories: [ \"samples\" ],\ntemperature: 0.5,\ninput: \".md\" }\n```\n\n\n\n</details>\n\n\n<details id=\"system-gptools\"><summary>system gptools</summary>\n\n###  `system` source\n\n```js\nsystem({ title: \"System prompt\" })\n$`You are concise. Answer in markdown.`\n```\n#### expanded\n``````markdown\nYou are concise. Answer in markdown.\n``````\n###  `system.explanations` source\n\n```js\nsystem({ title: \"Explain your answers\" })\n$`When explaining answers, take a deep breath.`\n```\n#### expanded\n``````markdown\nWhen explaining answers, take a deep breath.\n``````\n###  `system.files` source\n\n```js\nsystem({\n    title: \"File generation\",\n    description: \"Teaches the file format supported by GPTools\",\n})\n\nconst folder =\n    env.vars[\"outputFolder\"] || env.template.outputFolder\n$`When generating or updating files you will use the following syntax:`\n\ndef(\n    `File ${folder || \".\"}/file1.ts`,\n    `What goes in\\n${folder || \".\"}/file1.ts.`,\n    { language: \"typescript\" }\n)\ndef(\n    `File ${folder || \".\"}/file1.py`,\n    `What goes in\\n${folder || \".\"}/file1.py.`,\n    { language: \"python\" }\n)\ndef(\n    `File /path_to_file/file2.md`,\n    `What goes in\\n/path_to_file/file2.md.`,\n    { language: \"markdown\" }\n)\n\n$`Make sure to use precisely ${env.fence} to guard file code sections.`\n$`Make sure to use precisely ${env.markdownFence} to guard file markdown sections.`\n$`Use full path of filename in code section header.`\nif (folder) $`When generating new files, place files in folder \"${folder}\".`\n$`If a file does not have changes, do not regenerate.`\n```\n#### expanded\n``````markdown\nWhen generating or updating files you will use the following syntax:\n\nFile ./file1.ts:\n```\nWhat goes in\n./file1.ts.\n```\n\nFile ./file1.py:\n```\nWhat goes in\n./file1.py.\n```\n\nFile /path_to_file/file2.md:\n`````\nWhat goes in\n/path_to_file/file2.md.\n`````\n\nMake sure to use precisely ``` to guard file code sections.\n\nMake sure to use precisely ````` to guard file markdown sections.\n\nUse full path of filename in code section header.\n\nIf a file does not have changes, do not regenerate.\n``````\n###  `system.summary` source\n\n```js\nsystem({\n    title: \"Summarize\",\n    description: \"Generate a summary of the changes\",\n})\n\n$`Additionally, generate a concise SUMMARY of the changes in all files using the following syntax:`\n\ndef(`SUMMARY`, `This is a summary of the changes in files.`)\n```\n#### expanded\n``````markdown\nAdditionally, generate a concise SUMMARY of the changes in all files using the following syntax:\n\nSUMMARY:\n```\nThis is a summary of the changes in files.\n```\n``````\n\n\n</details>\n\n\n<details id=\"gptool-source\"><summary>gptool source</summary>\n\n\n```js\ngptool({\n    title: \"Generate BDD scenarios\",\n    description: \"Generate a Gherkin .feature file from the node and children.\",\n    categories: [\"samples\"],\n    temperature: 0.5\n})\n\ndef(\"FILE\", env.file)\ndef(\"FEATURE\", env.links.filter(f => f.filename.endsWith(\".feature\")))\n\n$`\nYou are an expert system designer that writes scenarios \nin a [Gherkin syntax](https://cucumber.io/docs/gherkin/reference/). \n\nUpdate FEATURE files to match requirements in FILE.\n\nLimit changes to existing scenarios to minimum, \nbut add new scenarios as needed. \n`\n```\n\n\n</details>\n\n\n<details id=\"gptool-expanded-prompt\"><summary>gptool expanded prompt</summary>\n\n-  model: `gpt-4`\n-  temperature: 0.5\n\n``````markdown\nFILE:\n````` file=problem.gpspec.md\n# email address recognizer\n\nWrite a function that takes a string argument and returns true if the whole string is a valid email address, false otherwise.\n-   [email_recognizer.py](email_recognizer.py)\n`````\n\nYou are an expert system designer that writes scenarios \nin a [Gherkin syntax](https://cucumber.io/docs/gherkin/reference/). \n\nUpdate FEATURE files to match requirements in FILE.\n\nLimit changes to existing scenarios to minimum, \nbut add new scenarios as needed. \n``````\n\n\n</details>\n\n\n<details id=\"LLM-response\"><summary>LLM response</summary>\n\n\n``````markdown\nFile ./problem.feature:\n```\nFeature: Email Address Recognizer\n  The function should take a string argument and return true if the whole string is a valid email address, false otherwise.\n\n  Scenario: Valid Email Address\n    Given a string \"test@example.com\"\n    When the function is called\n    Then it should return true\n\n  Scenario: Invalid Email Address\n    Given a string \"testexample.com\"\n    When the function is called\n    Then it should return false\n\n  Scenario: Empty String\n    Given a string \"\"\n    When the function is called\n    Then it should return false\n```\n\nSUMMARY:\n```\nUpdated the problem.feature file to include scenarios for checking if a given string is a valid email address.\n```\n``````\n\n\n</details>\n\n\n<details id=\"code-regions\"><summary>code regions</summary>\n\n-   `File ./problem.feature`\n`````feature\nFeature: Email Address Recognizer\n  The function should take a string argument and return true if the whole string is a valid email address, false otherwise.\n\n  Scenario: Valid Email Address\n    Given a string \"test@example.com\"\n    When the function is called\n    Then it should return true\n\n  Scenario: Invalid Email Address\n    Given a string \"testexample.com\"\n    When the function is called\n    Then it should return false\n\n  Scenario: Empty String\n    Given a string \"\"\n    When the function is called\n    Then it should return false\n\n`````\n\n-   `SUMMARY`\n`````\nUpdated the problem.feature file to include scenarios for checking if a given string is a valid email address.\n\n`````\n\n\n</details>\n","text":"File ./problem.feature:\n```\nFeature: Email Address Recognizer\n  The function should take a string argument and return true if the whole string is a valid email address, false otherwise.\n\n  Scenario: Valid Email Address\n    Given a string \"test@example.com\"\n    When the function is called\n    Then it should return true\n\n  Scenario: Invalid Email Address\n    Given a string \"testexample.com\"\n    When the function is called\n    Then it should return false\n\n  Scenario: Empty String\n    Given a string \"\"\n    When the function is called\n    Then it should return false\n```\n\nSUMMARY:\n```\nUpdated the problem.feature file to include scenarios for checking if a given string is a valid email address.\n```","summary":"Updated the problem.feature file to include scenarios for checking if a given string is a valid email address.\n"}}}
