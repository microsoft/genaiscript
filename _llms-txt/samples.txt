<SYSTEM>Samples: Advanced samples used for specific common scenarios</SYSTEM>

# Overview

> Fully fledged scripts ready to use.

The sample scripts are a collection of fully fledged scripts ready to use. They are designed to be used mostly as is, but we encourage you to tweak or modify them to suit your needs. [Awesome Scripts ](/genaiscript/samples/awesome)A curated list of awesome scripts [Diagram ](/genaiscript/samples/diagram)Class diagram generator [Lint ](/genaiscript/samples/lint)An Easy Universal Linter [Image Alt Textify ](/genaiscript/samples/iat)Generate alt text for images in markdown files [Spell Checker ](/genaiscript/samples/sc)Review documentation for spelling and grammar [Pull Request Reviewer ](/genaiscript/samples/prr)Review the current files or changes [Pull Request Descriptor ](/genaiscript/samples/prd)Generate a pull request description [GitHub Action Investigator ](/genaiscript/samples/gai)Investigate GitHub Actions failures [Git Commit Message ](/genaiscript/samples/gcm)Generate a commit message for all staged changes [Search and transform ](/genaiscript/samples/st)Search for a pattern in files and apply an LLM transformation to the match [Commenter ](/genaiscript/samples/cmt)Adds comments to your code

# Awesome Scripts

> A curated list of awesome scripts

These are a few scripts written by the community that are useful for various tasks. If you have a script that you think should be included, please submit a pull request to add it to this list. [Grumpy Dev ](https://github.com/sinedied/grumpydev-mcp/blob/main/genaisrc/review-code.genai.js)Let the grumpy senior dev review your code with this MCP server * [Submit your script](https://github.com/microsoft/genaiscript/edit/dev/docs/src/content/docs/samples/awesome.mdx).

# Commenter

> Adds comments to your code

This sample automates the process of adding comments to source code using an LLM and validates that the changes haven‚Äôt introduced any code modifications. To achieve this, we could use a combination of tools to validate the transformation: source formatters, compilers, linters, or an LLM-as-judge. The algorithm can be summarized as follows: ```txt for each file of files // generate add comments using GenAI // validate validate validate! format generated code (optional) -- keep things consistent build generated -- let's make sure it's still valid code check that only comments were changed -- LLM as a judge // and more validate final human code review ``` Let‚Äôs get started with analyzing the script. ### Getting Files to Process [Section titled ‚ÄúGetting Files to Process‚Äù](#getting-files-to-process) The user can select which files to comment on or, if none are selected, we‚Äôll use Git to find all modified files. ```ts let files = env.files if (files.length === 0) // no files selected, use git to find modified files files = await ..."git status --porcelain"... // details in sources ``` ### Processing Each File [Section titled ‚ÄúProcessing Each File‚Äù](#processing-each-file) We process each file separately to avoid overwhelming the token context and to keep the AI focused. We can use [inline prompts](/genaiscript/reference/scripts/inline-prompts) to make inner queries. ```ts for (const file of files) { ... add comments ... format generated code (optional) -- keep things consistent ... build generated -- let's make sure it's still valid code ... check that only comments were changed -- LLM as judge ... save changes } ``` ### The Prompt for Adding Comments [Section titled ‚ÄúThe Prompt for Adding Comments‚Äù](#the-prompt-for-adding-comments) Within the `addComments` function, we prompt GenAI to add comments. We do this twice to increase the likelihood of generating useful comments, as the LLM might have been less effective on the first pass. ```ts const res = await runPrompt( (ctx) => { ctx.$`You can add comments to this code...` // prompt details in sources }, { system: ["system", "system.files"] } ) ``` We provide a detailed set of instructions to the AI on how to analyze and comment on the code. ### Format, build, lint [Section titled ‚ÄúFormat, build, lint‚Äù](#format-build-lint) At this point, we have source code modified by an LLM. We should try to use all available tools to validate the changes. It is best to start with formatters and compilers, as they are deterministic and typically fast. ### Judge results with LLM [Section titled ‚ÄúJudge results with LLM‚Äù](#judge-results-with-llm) We issue one more prompt to judge the modified code (`git diff`) and make sure the code is not modified. ```ts async function checkModifications(filename: string): Promise<boolean> { const diff = await host.exec(`git diff ${filename}`) if (!diff.stdout) return false const res = await runPrompt( (ctx) => { ctx.def("DIFF", diff.stdout) ctx.$`You are an expert developer at all programming languages. Your task is to analyze the changes in DIFF and make sure that only comments are modified. Report all changes that are not comments and print "<MODIFIED>". ` }, { cache: "cmt-check", } ) return res.text?.includes("<MODIFIED>") } ``` ## How to Run the Script [Section titled ‚ÄúHow to Run the Script‚Äù](#how-to-run-the-script) To run this script, you‚Äôll first need to install the GenAIScript CLI. [Follow the installation guide here](https://microsoft.github.io/genaiscript/getting-started/installation). ```sh genaiscript run cmt ``` ## Format and build [Section titled ‚ÄúFormat and build‚Äù](#format-and-build) One important aspect is to normalize and validate the AI-generated code. The user can provide a `format` command to run a formatter and a `build` command to check if the code is still valid. ```ts script({..., parameters: { format: { type: "string", description: "Format source code command", }, build: { type: "string", description: "Build command", }, }, }) const { format, build } = env.vars.build ``` ```sh genaiscript run cmt --vars "build=npm run build" "format=npm run format" ``` ## Full source ([GitHub](https://github.com/microsoft/genaiscript/blob/main/packages/sample/genaisrc/samples/cmt.genai.mts)) [Section titled ‚ÄúFull source (GitHub)‚Äù](#full-source-github) cmt.genai.mts ```ts script({ title: "Source Code Comment Generator", description: `Add comments to source code to make it more understandable for AI systems or human developers.`, parameters: { format: { type: "string", description: "Format source code command", }, build: { type: "string", description: "Build command", }, }, }) const { format, build } = env.vars // Get files from environment or modified files from Git if none provided let files = env.files if (!files.length) files = await git.listFiles("staged", { askStageOnEmpty: true }) if (!files.length) files = await git.listFiles("modified-base") // custom filter to only process code files files = files.filter( ({ filename }) => /\.(py|m?ts|m?js|cs|java|c|cpp|h|hpp)$/.test(filename) && // known languages only !/\.test/.test(filename) // ignore test files ) // Shuffle files files = files.sort(() => Math.random() - 0.5) console.log(YAML.stringify(files.map((f) => f.filename))) // Process each file separately to avoid context explosion const jobs = host.promiseQueue(5) await jobs.mapAll(files, processFile) async function processFile(file: WorkspaceFile) { console.log(`processing ${file.filename}`) if (!file.content) console.log(`empty file, continue`) try { const newContent = await addComments(file) // Save modified content if different if (newContent && file.content !== newContent) { console.log(`updating ${file.filename}`) await workspace.writeText(file.filename, newContent) let revert = false // try formatting if (format) { const formatRes = await host.exec(`${format} ${file.filename}`) if (formatRes.exitCode !== 0) { revert = true } } // try building if (!revert && build) { const buildRes = await host.exec(`${build} ${file.filename}`) if (buildRes.exitCode !== 0) { revert = true } } // last LLM as judge check if (!revert) revert = await checkModifications(file.filename) // revert if (revert) { console.error(`reverting ${file.filename}...`) await workspace.writeText(file.filename, file.content) } } } catch (e) { console.error(`error: ${e}`) } } // Function to add comments to code async function addComments(file: WorkspaceFile): Promise<string | undefined> { let { filename, content } = file if (parsers.tokens(file) > 20000) return undefined // too big const res = await runPrompt( (ctx) => { // Define code snippet for AI context with line numbers const code = ctx.def( "CODE", { filename, content }, { lineNumbers: false } ) // AI prompt to add comments for better understanding ctx.def("FILE", code, { detectPromptInjection: "available" }) ctx.$`You are an expert developer at all programming languages. You are tasked with adding comments to code in FILE to make it more understandable for AI systems or human developers. You should analyze it, and add/update appropriate comments as needed. To add or update comments to this code, follow these steps: 1. Analyze the code to understand its structure and functionality. - If you are not familiar with the programming language, emit an empty file. - If there is no code, emit an empty file. 2. Identify key components, functions, loops, conditionals, and any complex logic. 3. Add comments that explain: - The purpose of functions or code blocks using the best comment format for that programming language. - How complex algorithms or logic work - Any assumptions or limitations in the code - The meaning of important variables or data structures - Any potential edge cases or error handling - All function arguments and return value - A Top level file comment that describes the code in the file When adding or updating comments, follow these guidelines: - Use clear and concise language - Avoid stating the obvious (e.g., don't just restate what the code does) - Focus on the "why" and "how" rather than just the "what" - Use single-line comments for brief explanations - Use multi-line comments for longer explanations or function/class descriptions - Always place comments above the code they refer to. - If comments already exist, review and update them as needed. - Minimize changes to existing comments. - For TypeScript functions, classes and fields, use JSDoc comments. do NOT add type annotations in comments. - For Python functions and classes, use docstrings. - do NOT modify comments with TODOs. - do NOT modify comments with URLs or links as they are reference to external resources. - do NOT add comments to imports Your output should be the original code with your added comments. Make sure to preserve ALL the original code's formatting and structure. DO NOT BE LAZY. Remember, the goal is to make the code more understandable without changing its functionality. DO NOT MODIFY THE CODE ITSELF. Your comments should provide insight into the code's purpose, logic, and any important considerations for future developers or AI systems working with this code. ` }, { system: [ "system.assistant", "system.safety_jailbreak", "system.safety_harmful_content", "system.safety_validate_harmful_content", ], label: `comment ${filename}`, } ) const { text, fences } = res const newContent = fences?.[0]?.content ?? text return newContent } async function checkModifications(filename: string): Promise<boolean> { const diff = await git.diff({ paths: filename }) if (!diff) return false const res = await runPrompt( (ctx) => { ctx.def("DIFF", diff, { language: "diff" }) ctx.$`You are an expert developer at all programming languages. Your task is to analyze the changes in DIFF and make sure that only comments are modified. Report all changes that are not comments or spacing and print <MOD>; otherwise, print <NO_MOD>. ` }, { system: ["system.assistant", "system.safety_jailbreak"], cache: "cmt-check", label: `check comments in ${filename}`, } ) const modified = res.text?.includes("<MOD>") || !res.text?.includes("<NO_MOD>") return modified } ``` ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content: * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) * The generated description is saved to a file at a specific path, which allows for a manual review before committing the changes. Additional measures to further enhance safety include running [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validating the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.

# Diagram

> Class diagram generator

This sample analyzes all the code in context and attempts to generate a diagram using [mermaid](https://mermaid.js.org/). diagram.genai.mts ```ts script({ title: "Generate a class diagram using mermaid of the code symbols in content.", group: "copilot", }) def("CODE", env.files) $`Generate a class diagram using mermaid of the code symbols in the CODE.` ```

# GitHub Action Investigator

> Investigate GitHub Actions failures

The following sample shows a script that analyzes a GitHub Action Workflow Job log and attempts to determine the root cause of the issue. ## Strategy [Section titled ‚ÄúStrategy‚Äù](#strategy) The script is a hybrid between traditional software and LLM/Agent based software. We start by collecting relevant information for the LLM, to fill the context with relevant information then we let the agent reason and ask for more information as needed through tools. The first part of the script is a traditional software that collects the information and prepares the context for the LLM. It uses the following simple strategy: * find information about the failed workflow run, including commit, and job logs * find the last successful workflow run if any, and gather the commit, and job lobs * build a LLM context with all the information, including commit diffs, and job lobs diffs. The information gathered is this section is **not** hallucinated by design and added to the final output using the `env.output` object. The second part is an agent that uses the LLM to reason about the information and ask for more information as needed. ## Add the script [Section titled ‚ÄúAdd the script‚Äù](#add-the-script) * Open your GitHub repository and start a new pull request. * Add the following script to your repository as `genaisrc/prr.genai.mts`. gai.genai.mts ```ts script({ title: "GitHub Action Investigator", description: "Analyze GitHub Action runs to find the root cause of a failure", parameters: { /** the user can get the url from the github web * like 14890513008 or https://github.com/microsoft/genaiscript/actions/runs/14890513008 */ runId: { type: "number", description: "Run identifier", }, jobId: { type: "number", description: "Job identifier", }, runUrl: { type: "string", description: "Run identifier or URL", }, }, system: [ "system", "system.assistant", "system.annotations", "system.files", ], flexTokens: 30000, cache: "gai", tools: ["agent_fs", "agent_github", "agent_git"], }) const { dbg, output, vars } = env output.heading(2, "Investigator report") output.heading(3, "Context collection") const { owner, repo } = await github.info() let runId: number = vars.runId let jobId: number = vars.jobId if (isNaN(runId)) { const runUrl = vars.runUrl output.itemLink(`run url`, runUrl) // Retrieve repository information const { runRepo, runOwner, runIdUrl, jobIdUrl } = /^https:\/\/github\.com\/(?<runOwner>\w+)\/(?<runRepo>\w+)\/actions\/runs\/(?<runIdUrl>\d+)?(\/job\/(?<jobIdRun>\d+))?/i.exec( runUrl )?.groups || {} if (!runRepo) throw new Error( "Url not recognized. Please provide a valid URL https://github.com/<owner>/<repo>/actions/runs/<runId>/..." ) runId = parseInt(runIdUrl) dbg(`runId: ${runId}`) jobId = parseInt(jobIdUrl) dbg(`jobId: ${jobId}`) if (runOwner !== owner) cancel( `Run owner ${runOwner} does not match the current repository owner ${owner}` ) if (runRepo !== repo) cancel( `Run repository ${runRepo} does not match the current repository ${repo}` ) } if (isNaN(runId)) throw new Error("You must provide a runId or runUrl") output.itemValue(`run id`, runId) // fetch run const run = await github.workflowRun(runId) dbg(`run: %O`, run) const branch = run.head_branch dbg(`branch: ${branch}`) const workflow = await github.workflow(run.workflow_id) dbg(`workflow: ${workflow.name}`) // List workflow runs for the specified workflow and branch const runs = await github.listWorkflowRuns(workflow.id, { status: "completed", branch, count: 100, }) runs.reverse() // from newest to oldest dbg( `runs: %O`, runs.map(({ id, conclusion, workflow_id, html_url, run_started_at }) => ({ id, conclusion, workflow_id, html_url, run_started_at, })) ) const reversedRuns = runs.filter( (r) => new Date(r.run_started_at) <= new Date(run.run_started_at) ) if (!reversedRuns.length) cancel("No runs found") dbg( `reversed runs: %O`, reversedRuns.map( ({ id, conclusion, workflow_id, html_url, run_started_at }) => ({ id, conclusion, workflow_id, html_url, run_started_at, }) ) ) const firstFailedJobs = await github.listWorkflowJobs(run.id) const firstFailedJob = firstFailedJobs.find(({ conclusion }) => conclusion === "failure") ?? firstFailedJobs[0] const firstFailureLog = firstFailedJob.content if (!firstFailureLog) cancel("No logs found") output.itemLink(`failed job`, firstFailedJob.html_url) // resolve the latest successful workflow run const lastSuccessRun = reversedRuns.find( ({ conclusion }) => conclusion === "success" ) if (lastSuccessRun) output.itemLink( `last successful run #${lastSuccessRun.run_number}`, lastSuccessRun.html_url ) else output.item(`last successful run not found`) let gitDiffRef: string let logRef: string let logDiffRef: string if (lastSuccessRun) { if (lastSuccessRun.head_sha === run.head_sha) { console.debug("No previous successful run found") } else { output.itemLink( `diff (${lastSuccessRun.head_sha.slice(0, 7)}...${run.head_sha.slice(0, 7)})`, `https://github.com/${owner}/${repo}/compare/${lastSuccessRun.head_sha}...${run.head_sha}` ) // Execute git diff between the last success and failed run commits await git.fetch("origin", lastSuccessRun.head_sha) await git.fetch("origin", run.head_sha) const gitDiff = await git.diff({ base: lastSuccessRun.head_sha, head: run.head_sha, excludedPaths: "**/genaiscript.d.ts", }) if (gitDiff) { gitDiffRef = def("GIT_DIFF", gitDiff, { language: "diff", lineNumbers: true, flex: 1, }) } } } if (!lastSuccessRun) { // Define log content if no last successful run is available logRef = def("LOG", firstFailureLog, { maxTokens: 20000, lineNumbers: false, }) } else { const lastSuccessJobs = await github.listWorkflowJobs(lastSuccessRun.id) const lastSuccessJob = lastSuccessJobs.find( ({ name }) => firstFailedJob.name === name ) if (!lastSuccessJob) console.debug( `could not find job ${firstFailedJob.name} in last success run` ) else { output.itemLink(`last successful job`, lastSuccessJob.html_url) const jobDiff = await github.diffWorkflowJobLogs( firstFailedJob.id, lastSuccessJob.id ) // Generate a diff of logs between the last success and failed runs logDiffRef = def("LOG_DIFF", jobDiff, { language: "diff", lineNumbers: false, }) } } // Instruction for generating a report based on the analysis $`Your are an expert software engineer and you are able to analyze the logs and find the root cause of the failure. ${lastSuccessRun ? `You are analyzing 2 GitHub Action Workflow Runs: a SUCCESS_RUN and a FAILED_RUN.` : ""} ${gitDiffRef ? `- ${gitDiffRef} contains a git diff of the commits of SUCCESS_RUN and FAILED_RUN` : ""} ${logDiffRef ? `- ${logDiffRef} contains a workflow job diff of SUCCESS_RUN and FAILED_RUN` : ""} ${logRef ? `- ${logRef} contains the log of the FAILED_RUN` : ""} ${lastSuccessRun ? `- The SUCCESS_RUN is the last successful workflow run (head_sha: ${lastSuccessRun})` : ""} - The FAILED_RUN is the workflow run that failed (head_sha: ${run.head_sha}) ## Task Analyze the diff in LOG_DIFF and provide a summary of the root cause of the failure. Show the code that is responsible for the failure. If you cannot find the root cause, stop. Investigate potential fixes for the failure. If you find a solution, generate a diff with suggested fixes. Use a diff format. If you cannot locate the error, do not generate a diff. ## Instructions Use 'agent_fs', 'agent_git' and 'agent_github' if you need more information. Do not invent git or github information. You have access to the entire source code through the agent_fs tool. ` output.heading(2, `AI Analysis`) ``` ## Automate with GitHub Actions [Section titled ‚ÄúAutomate with GitHub Actions‚Äù](#automate-with-github-actions) Using [GitHub Actions](https://docs.github.com/en/actions) and [GitHub Models](https://docs.github.com/en/github-models), you can automate the execution of the script and creation of the comments. You can decide to turn on/off the agentic part of the script my commenting out the `agent_*` line. A script without agent has a predictable token consumption behavior (it‚Äôs 1 LLM call); an agentic script will go into a loop and will consume more tokens, but it will be able to ask for more information if needed. gai.yml ```yaml name: genai investigator on: workflow_run: workflows: ["build", "playwright", "ollama"] types: - completed concurrency: group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event.workflow_run.event }}-${{ github.event.workflow_run.conclusion }} cancel-in-progress: true permissions: contents: read actions: read pull-requests: write models: read jobs: investigate: # Only run this job if the workflow run concluded with a failure # and was triggered by a pull request event if: ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.event == 'pull_request' }} runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: submodules: "recursive" fetch-depth: 10 - uses: actions/setup-node@v4 with: node-version: "20" cache: yarn - run: yarn install --frozen-lockfile - name: compile run: yarn compile - name: genaiscript gai run: node packages/cli/built/genaiscript.cjs run gai -p github -pr ${{ github.event.workflow_run.pull_requests[0].number }} -prc --vars "runId=${{ github.event.workflow_run.id }}" --out-trace $GITHUB_STEP_SUMMARY env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} ``` ## Are we done yet? [Section titled ‚ÄúAre we done yet?‚Äù](#are-we-done-yet) No! This script is far from perfect and in fact, it probably needs better heuristics to build the context **that is specific to your repository**. This is a good starting point, but you will need to tweak the heuristics to make it work for your repository.

# Git Commit Message

> Generate a commit message for all staged changes

The `gcm` script provides a guided flow to create commits with generated messages. It starts by generating a commit message based on the staged changes in your Git repository using an [inline prompt](/genaiscript/reference/scripts/inline-prompts), and then asks the user to commit the changes or regenerate the message. ```text compute diff loop generate commit message ask user to commit, edit message or regenerate if user says commit git commit and push ``` ## Configuration [Section titled ‚ÄúConfiguration‚Äù](#configuration) First, we define the `script` function, which sets up our GenAI script by providing a title and a description, and specifying the model we‚Äôll be using: ```ts script({ title: "git commit message", description: "Generate a commit message for all staged changes", model: "openai:gpt-4o", }) ``` ## Look for changes [Section titled ‚ÄúLook for changes‚Äù](#look-for-changes) Next, we check for any staged changes in your Git repository using `git diff`. If there is nothing staged, GenAI kindly offers to stage all changes for you: ```ts // Check for staged changes and stage all changes if none are staged const diff = await git.diff({ staged: true, askStageOnEmpty: true, }) if (!diff) cancel("no staged changes") ``` We then log the diff to the console so you can review what changes are about to be committed: ```ts console.log(diff.stdout) ``` ## Generate and refine commit message [Section titled ‚ÄúGenerate and refine commit message‚Äù](#generate-and-refine-commit-message) Here comes the interesting part. We enter a loop where GenAI will generate a commit message for you based on the diff. If you‚Äôre not satisfied with the message, you can choose to edit it, accept it, or regenerate it: ```ts let choice let message do { // generate a conventional commit message (https://www.conventionalcommits.org/en/v1.0.0/) const res = await runPrompt((_) => { _.def("GIT_DIFF", diff, { maxTokens: 20000, language: "diff" }) _.$`Generate a git conventional commit message for the changes in GIT_DIFF. - do NOT add quotes - maximum 50 characters - use gitmojis` }) // ... handle response and user choices } while (choice !== "commit") ``` ## Commit and push [Section titled ‚ÄúCommit and push‚Äù](#commit-and-push) If you choose to commit, GenAI runs the `git commit` command with your message, and if you‚Äôre feeling super confident, it can even push the changes to your repository right after: ```ts if (choice === "commit" && message) { console.log( (await host.exec("git", ["commit", "-m", message, "-n"])).stdout ) if (await host.confirm("Push changes?", { default: true })) console.log((await host.exec("git push")).stdout) } ``` ## Running the Script with GenAIScript CLI [Section titled ‚ÄúRunning the Script with GenAIScript CLI‚Äù](#running-the-script-with-genaiscript-cli) Use the [cli](/genaiscript/reference/cli) to run the script: ```shell npx genaiscript run gcm ``` ## Full source ([GitHub](https://github.com/microsoft/genaiscript/blob/main/packages/sample/genaisrc/samples/gcm.genai.mts)) [Section titled ‚ÄúFull source (GitHub)‚Äù](#full-source-github) gcm.genai.mts ```ts /** * Script to automate the git commit process with AI-generated commit messages. * It checks for staged changes, generates a commit message, and prompts the user to review or edit the message before committing. */ script({ title: "git commit message", description: "Generate a commit message for all staged changes", unlisted: true, parameters: { chunkSize: { type: "number", default: 10000, description: "Maximum number of tokens per chunk", }, maxChunks: { type: "number", default: 4, description: "Safeguard against huge commits. Asks confirmation to the user before running more than maxChunks chunks", }, gitmoji: { type: "boolean", default: true, description: "Use gitmoji in the commit message", }, }, }) const { chunkSize, maxChunks, gitmoji } = env.vars // Check for staged changes and stage all changes if none are staged const diff = await git.diff({ staged: true, askStageOnEmpty: true, ignoreSpaceChange: true, }) // If no staged changes are found, cancel the script with a message if (!diff) cancel("no staged changes") // Display the diff of staged changes in the console console.debug(diff) await git.pull() // chunk if case of massive diff const chunks = await tokenizers.chunk(diff, { chunkSize }) if (chunks.length > 1) { console.log(`staged changes chunked into ${chunks.length} parts`) if (chunks.length > maxChunks) { const res = await host.confirm( `This is a big diff with ${chunks.length} chunks, do you want to proceed?` ) if (!res) cancel("user cancelled") } } const gitPush = async () => { if (await host.confirm("Push changes?", { default: true })) console.log(await git.exec("push")) } const addInstructions = (ctx) => { ctx.$` <type>: <description> <body> ${gitmoji ? `- <type> is a gitmoji` : `- <type> can be one of the following: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert`} - <description> is a short, imperative present-tense description of the change - <body> is a short description of the changes - Pretend you're writing an important newsworthy article. Give the headline in <description> that will sum up what happened and what is important. Then, provide further details in the <body> in an organized fashion. - the diff is generated by "git diff" - do NOT use markdown syntax - do NOT add quotes, single quote or code blocks - keep <description> short, 1 LINE ONLY, maximum 50 characters - keep <body> short, 1 LINE ONLY, maximum 72 characters - follow the conventional commit spec at https://www.conventionalcommits.org/en/v1.0.0/#specification - do NOT confuse delete lines starting with '-' and add lines starting with '+' ` } let choice let message do { // Generate a conventional commit message based on the staged changes diff message = "" for (const chunk of chunks) { const res = await runPrompt( (_) => { _.def("GIT_DIFF", chunk, { maxTokens: 10000, language: "diff", detectPromptInjection: "available", }) _.$`Generate a git conventional commit message that summarizes the changes in GIT_DIFF.` addInstructions(_) }, { model: "large", // Specifies the LLM model to use for message generation label: "generate commit message", // Label for the prompt task system: ["system.assistant"], systemSafety: true, responseType: "text", } ) if (res.error) throw res.error message += (res.fences?.[0]?.content || res.text) + "\n" } // since we've concatenated the chunks, let's compress it back into a single sentence again if (chunks.length > 1) { const res = await runPrompt( (_) => { _.$`Generate a git conventional commit message that summarizes the <COMMIT_MESSAGES>.` addInstructions(_) _.def("COMMIT_MESSAGES", message) }, { model: "large", label: "summarize chunk commit messages", system: ["system.assistant"], systemSafety: true, responseType: "text", } ) if (res.error) throw res.error message = res.text } message = message?.trim() if (!message) { console.log( "No commit message generated, did you configure the LLM model?" ) break } // Prompt user to accept, edit, or regenerate the commit message choice = await host.select(message, [ { value: "commit", description: "accept message and commit", }, { value: "edit", description: "edit message in git editor", }, { value: "regenerate", description: "run LLM generation again", }, { value: "cancel", description: "cancel commit", }, ]) // Handle user's choice for commit message if (choice === "edit") { // @ts-ignore const { spawnSync } = await import("child_process") // 1) Launch git commit in an interactive editor const spawnResult = spawnSync( "git", ["commit", "-m", message, "--edit"], { stdio: "inherit", } ) // 2) After the editor closes, forcibly exit the entire script console.debug("git editor closed with exit code ", spawnResult.status) if (spawnResult.status === 0) await gitPush() break } // If user chooses to commit, execute the git commit and optionally push changes if (choice === "commit" && message) { console.log(await git.exec(["commit", "-m", message])) await gitPush() break } if (choice === "cancel") { cancel("User cancelled commit") break } } while (choice !== "commit") ``` ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) * The commit message is reviewed and approved by the user before committing the changes. Additional measures to further enhance safety include running [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validating the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.

# Image Alt Textify

> Generate alt text for images in markdown files

Alt text is essential for making images accessible to everyone, including those with visual impairments. It provides a textual description of the image, allowing screen readers to convey the content to users who cannot see the image. However, writing alt text for images can be time-consuming, especially when dealing with a large number of images. This is where AI can help. By using a language model like OpenAI‚Äôs GPT-4, you can generate alt text for images automatically, thus saving time and effort. In this sample, we will build a tool that generates alt text for images in Markdown files. ## Configuring the script [Section titled ‚ÄúConfiguring the script‚Äù](#configuring-the-script) This script is composed of TypeScript code, designed to run with the GenAIScript CLI. Let‚Äôs break it down: ```ts script({ title: "Image Alt Textify", description: "Generate alt text for images in markdown files", accept: "none", parameters: { docs: { type: "string", description: "path to search for markdown files", default: "**.{md,mdx}", }, force: { type: "boolean", description: "regenerate all descriptions", default: false, }, assets: { type: "string", description: "image assets path", // change the default path to your assets folder default: "./assets/images", }, }, }) ``` Here we declare the script with a title and description, specifying it uses OpenAI‚Äôs GPT-4 model. We also set parameters for the file paths, the option to regenerate all descriptions, and the assets path. Next, we extract environmental variables: ```ts const { docs, force, assets } = env.vars ``` ## Searching for images [Section titled ‚ÄúSearching for images‚Äù](#searching-for-images) Following that, we define a regular expression to find images in Markdown: ```ts const rx = force ? // match ![alt?](path) with alt text or not /!\[[^\]]*\]\(([^\)]+\.(png|jpg))\)/g : // match ![](path) without alt text /!\[\s*\]\(([^\)]+\.(png|jpg))\)/g const { files } = await workspace.grep(rx, { path: docs, glob: "*.{md,mdx}", readText: true, }) ``` The script uses [workspace.grep](/genaiscript/reference/scripts/files#grep) to find all occurrences of the regex pattern in the specified documents. ## Generating alt text [Section titled ‚ÄúGenerating alt text‚Äù](#generating-alt-text) For each image URL found, we generate alt text using an [inline prompt](/genaiscript/reference/scripts/inline-prompts) and [defImages](/genaiscript/reference/scripts/images). ```ts for (const file of files) { const { filename, content } = file // map documentation relative path to assets path const url = resolveUrl(filename) // execute a LLM query to generate alt text const { text } = await runPrompt( (_) => { _.defImages(resolvedUrl) _.$` You are an expert in assistive technology. You will analyze the image and generate a description alt text for the image. - Do not include alt text in the description. - Keep it short but descriptive. - Do not generate the [ character.` }, { // safety system message to prevent generating harmful text system: ["system.safety_harmful_content"], // use multi-model model model: "openai:gpt-4o", ... } ) imgs[url] = text } ``` ## Updating files [Section titled ‚ÄúUpdating files‚Äù](#updating-files) Finally, we update the Markdown content with the generated alt text: ```ts const newContent = content.replace( rx, (m, url) => `![${imgs[url] ?? ""}](${url})` ) if (newContent !== content) await workspace.writeText(filename, newContent) ``` We replace the placeholder in the original content with the alt text and save the updated file. ## üíª How to Run the Script [Section titled ‚Äúüíª How to Run the Script‚Äù](#-how-to-run-the-script) To run this script, you‚Äôll need the GenAIScript CLI. If you haven‚Äôt installed it yet, check out the [installation guide](https://microsoft.github.io/genaiscript/getting-started/installation). Once you have the CLI, you can run the script with the following command: ```bash npx genaiscript run iat ``` ## Automate with GitHub Actions and GitHub Models [Section titled ‚ÄúAutomate with GitHub Actions and GitHub Models‚Äù](#automate-with-github-actions-and-github-models) The following GitHub Action automates the process of generating alt text for images in Markdown files. It runs on every push to the `dev` branch and uses the `genaiscript` CLI to execute the script. It uses the OpenAI `gpt-4.1` model through GitHub Models for inference. .github/workflows/genai-iat.yml ```yml name: genai iat on: workflow_dispatch: push: branches: - dev paths: - "**.md*" concurrency: group: iat-${{ github.workflow }}-${{ github.ref }} cancel-in-progress: true permissions: pull-requests: write models: read contents: write jobs: generate-alt-text: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 - name: genaiscript run: npx --yes genaiscript run iat -m github:openai/gpt-4.1 --out-trace $GITHUB_STEP_SUMMARY env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} - uses: stefanzweifel/git-auto-commit-action@v5 with: commit_message: "[genai] image alt text" commit_user_name: "genaiscript" ``` ## Full source ([GitHub](https://github.com/microsoft/genaiscript/blob/main/packages/sample/genaisrc/samples/iat.genai.mts)) [Section titled ‚ÄúFull source (GitHub)‚Äù](#full-source-github) iat.genai.mts ```ts /* * Markdown image alt text updater */ script({ title: "Image Alt Textify", description: "Generate alt text for images in markdown files", accept: "none", unlisted: true, parameters: { docs: { type: "string", description: "path to search for markdown files", default: "docs", }, force: { type: "boolean", description: "regenerate all descriptions", default: false, }, assets: { type: "string", description: "image assets path", default: "./slides/public", }, dryRun: { type: "boolean", description: "show matches, do not compute alt text", default: false, }, }, }) /** ------------------------------------------------ * Configuration */ const { docs, force, assets, dryRun } = env.vars /** ------------------------------------------------ * Helper functions (update as needed) */ /** * Return the resolved url for the image */ const resolveUrl = (filename: string, url: string) => { // github assets ok if (/^https:\/\/github.com\/user-attachments\/assets\//i.test(url)) return url if (url?.startsWith("https://raw.githubusercontent.com/")) return url // ignore external urls if (/^http?s:\/\//i.test(url)) return undefined // map / to assets else if (/^\//.test(url)) return path.join(assets, url.slice(1)) // resolve local paths else return path.join(path.dirname(filename), url) } /** ------------------------------------------------ * Collect files */ // search for ![](...) in markdown files and generate alt text for images const rx = force // upgrade all urls ? // match ![alt](url) with any alt /!\[[^\]]*\]\(([^\)]+)\)/g : // match ![alt](url) where alt is empty /!\[\s*\]\(([^\)]+)\)/g console.log(`Searching for ${rx} in ${docs}`) const { files } = await workspace.grep(rx, { path: docs, glob: "**/*.md*", readText: true, }) /** ------------------------------------------------ * Generate alt text for images * and update markdown files */ // a cache of generated alt text for images const imgs: Record<string, string> = {} // process each file for (const file of files) { const { filename, content } = file console.log(filename) const matches = Array.from(content.matchAll(rx)) console.log(`.. found ${matches.length} matches`) // pre-compute matches for (const match of matches) { const url = match[1] if (imgs[url]) continue // already processed console.log(`.. processing ${url}`) const resolvedUrl = resolveUrl(filename, url) if (!resolvedUrl) { console.log(`... unknown image url`) continue // can't process url } console.log(`‚îî‚îÄ ${resolvedUrl}`) if (dryRun) continue // execute a LLM query to generate alt text const { text, error } = await runPrompt( (_) => { _.defImages(resolvedUrl) _.$` You are an expert in assistive technology. You will analyze the image and generate a description alt text for the image. - Do not include alt text in the description. - Keep it short but descriptive. - Do not generate the [ character.` }, { // safety system message to prevent generating harmful text system: [ "system.assistant", "system.safety_jailbreak", "system.safety_harmful_content", "system.safety_validate_harmful_content", ], maxTokens: 4000, temperature: 0.5, cache: "alt-text", label: `alt-textify ${resolvedUrl}`, } ) if (error) throw error else if (!text) console.log(`.. no description generated`) else imgs[url] = text.replace(/\[/g, "") // remove [ from alt text } // apply replacements const newContent = content.replace( rx, (m, url) => `![${imgs[url] ?? ""}](${url})` ) // save updated content if (newContent !== content) { console.log(`.. updating ${filename}`) await workspace.writeText(filename, newContent) } } ``` ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) * The generated description is saved to a file at a specific path, which allows for manual review before committing the changes. Additional measures to further enhance safety would be to run [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validate the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.

# Lint

> An Easy Universal Linter

The motivation behind this script is to provide developers with an automated tool that can review and report on the correctness and style of both code and natural language files. It leverages the power of LLMs to inspect code or documents in new ways. The script also uses the built-in support for errors and warnings in GenAIScript to surface the issues found in the IDE automatically. ![Screenshot of a TypeScript file in a code editor showing a class named "Greeter" with a constructor and a method. The editor highlights four problems: missing semicolons on lines 5 and 9, an empty function on line 18, and a suggestion to add a type annotation on line 20. The right panel displays these issues with red and yellow icons. ](/genaiscript/_astro/lint-copilot.DUihL2v8_1lrrQL.webp) ### Script Breakdown [Section titled ‚ÄúScript Breakdown‚Äù](#script-breakdown) Below is a step-by-step explanation of the script: ```ts script({ title: "Universal Linter", description: "Review files for correctness and style", model: "large", system: [ "system", "system.assistant", "system.annotations", "system.safety_jailbreak", "system.safety_harmful_content", ], }) ``` * **`script({...})`**: This function initializes a GenAI script. * **`title`**: A label for the script, ‚ÄúUniversal Linter‚Äù, which succinctly describes its purpose. * **`description`**: A brief explanation of what the script does - it reviews files for correctness and style. * **`model`**: Specifies the use of a ‚Äúlarge‚Äù AI model to leverage advanced processing capabilities. * **`system`**: An array listing different system modules necessary for the script‚Äôs operation, including safety measures and annotation systems. The script also contains a prompt block: ```ts $`## Task You are Linty, a linter for all known programming languages and natural languages. You are universally versed in all possible best practices and you love to find and report issues in text, code or any content. Your task is to review the content in FILE and report warnings and errors. ## Rules - for each file in FILE, use best practices based on the file extension to review the content. For example, for a ".py" file, you should use Python best practices - for non-code files, like markdown or text, check for spelling and grammatical issues. - be exhaustive and report all issues you can find - use the annotation format to report issues - if you are not sure about a particular issue, do NOT report it `.role("system") ``` * **`$``Task`**: Begins a prompt section where the AI‚Äôs task is defined. * **`You are Linty...`**: Sets the role and personality of the AI as ‚ÄúLinty‚Äù, a diligent linter for various languages. * **`Your task...`**: Clearly defines the AI‚Äôs responsibility to review files and provide feedback on errors and warnings. * **`Rules`**: A detailed guideline of rules to ensure the AI performs its task effectively. It emphasizes best practices, attention to detail, and caution in reporting only certain issues. Finally, the script specifies files to be processed: ```ts def("FILE", env.files, { lineNumbers: true }) ``` * **`def("FILE", env.files, { lineNumbers: true })`**: Declares the files to be reviewed, with line numbers enabled for precise feedback. ### Running the Script [Section titled ‚ÄúRunning the Script‚Äù](#running-the-script) To execute this script, you can run it from Visual Studio Code or use the GenAIScript CLI. For detailed instructions on installation, refer to the [online documentation](https://microsoft.github.io/genaiscript/getting-started). ```bash genaiscript run lint <file1> <file2> ... ``` This command will run the ‚ÄúUniversal Linter‚Äù script, processing files as defined. From the GitHub Copilot Chat window, you can run the linter on all the files in the context by running: ```sh @genaiscript /run lint ``` ## Full Source [Section titled ‚ÄúFull Source‚Äù](#full-source) The full source code is available at <https://github.com/microsoft/genaiscript/blob/main/packages/sample/genaisrc/lint.genai.mts>. ``` script({ title: "Universal Linter", description: "Review files for correctness and style", model: "large", system: [ "system", "system.assistant", "system.annotations", "system.safety_jailbreak", "system.safety_harmful_content", ], }) $`## Task You are Linty, an linter for all known programming languages and natural languages. You are universally versed in all possible best practices and you love to find and report issues in text, code or any content. Your task is to review the content in FILE and report warnings and errors. ## Rules - for each file in FILE, use best practices based on the file extension to review the content. For example, for a ".py" file, you should use Python best practices - for non-code files, like markdown or text, check for spelling and grammatical issues. - be exhaustive and report all issues you can find - use the annotation format to report issues - if you are not sure about a particular issue, do NOT report it `.role("system") def("FILE", env.files, { lineNumbers: true }) ```

# Pull Request Descriptor

> Generate a pull request description

The following sample shows a script that generate a description of the changes in a pull request. We will develop the script locally and then create a GitHub Action to run it automatically. ## Add the script [Section titled ‚ÄúAdd the script‚Äù](#add-the-script) * **Create a new branch** in your repository. * Add the following script to your repository as `prd.genai.mts` in the `.genaisrc` folder. genaisrc/prd.genai.mts ```ts script({ title: "Pull Request Descriptor", description: "Generate a description for the current pull request", systemSafety: true, parameters: { base: "", }, }) const { dbg, vars } = env const base = vars.base || (await git.defaultBranch()) const changes = await git.diff({ base, llmify: true, }) if (!changes) cancel("No changes found in the pull request") dbg(`changes: %s`, changes) const gitDiff = def("GIT_DIFF", changes, { language: "diff", maxTokens: 14000, detectPromptInjection: "available", }) $`## Task You are an expert code reviewer with great English technical writing skills. Your task is to generate a high level summary of the changes in ${gitDiff} for a pull request in a way that a software engineer will understand. This description will be used as the pull request description. ## Instructions - do NOT explain that GIT_DIFF displays changes in the codebase - try to extract the intent of the changes, don't focus on the details - use bullet points to list the changes - use gitmojis to make the description more engaging - focus on the most important changes - do not try to fix issues, only describe the changes - ignore comments about imports (like added, remove, changed, etc.) ` ``` * run the [GenAIScript cli](/genaiscript/reference/cli/) to add the type definition files and fix the syntax errors in the editor (optional). ```bash npx --yes genaiscript script fix ``` The script starts with a metadata section (`script({ ... })`) that defines the title, description, and system safety options. The script then uses the `git` tool to get the diff of the pull request and stores it in the `GIT_DIFF` variable. The script then uses the `$` template literal to generate a report based on the diff. The report includes best practices for the programming language of each file, and it is important to analyze all the code. The script also includes a note to use tools to read the entire file content to get more context and to avoid reporting warnings. ## Run the script locally [Section titled ‚ÄúRun the script locally‚Äù](#run-the-script-locally) Make sure to commit your changes to the branch and push it to GitHub. Then **create a new pull request**. Since you are already in a pull request, you can run with the script and tune the prompting to your needs. You can use the GenAIScript Visual Studio Code extension or use the cli. ```sh npx --yes genaiscript run prd ``` You will see an output similar to the following. In the output, you will find links to the run reports (markdown files), information about the model, preview of the messages and the token usage. Open the `trace` or `output` reports in your favorite Markdown viewer to inspect the results. This part of the development is fully local so it‚Äôs your opportunity to refine the prompting. ```text ‚îå‚îÄüí¨ github:gpt-4.1 ‚úâ 2 ~‚Üë729t ‚îå‚îÄüìô system ‚îÇ## Safety: Jailbreak ‚îÇ... (18 lines) ‚îÇ- **Do NOT use function names starting with 'functions.'. ‚îÇ- **Do NOT respond with multi_tool_use**. ‚îå‚îÄüë§ user ‚îÇ<GIT_DIFF lang="diff"> ‚îÇ--- genaisrc/prd.genai.mts ‚îÇ+++ genaisrc/prd.genai.mts ‚îÇ@@ -2,7 +2,7 @@ script({ ‚îÇ[2] title: "Pull Request Descriptor", ‚îÇ[3] description: "Generate a description for the current pull request", ‚îÇ... (24 lines) ‚îÇ- try to extract the intent of the changes, don't focus on the details ‚îÇ- use bullet points to list the changes ‚îÇ- use gitmojis to make the description more engaging ‚îÇ- focus on the most important changes ‚îÇ- do not try to fix issues, only describe the changes ‚îÇ- ignore comments about imports (like added, remove, changed, etc.) - üîí Removed agent_git tool from both "Pull Request Descriptor" and "Pull Request Reviewer" scripts, leaving only the agent_fs tool enabled - üõ°Ô∏è Maintained systemSafety and general parameter structure unchanged in both scripts ‚îî‚îÄüèÅ github:gpt-4.1 ‚úâ 2 1165ms ‚áÖ 909t ‚Üë844t ‚Üì65t 0.221¬¢ ``` ## Automate with GitHub Actions [Section titled ‚ÄúAutomate with GitHub Actions‚Äù](#automate-with-github-actions) Using [GitHub Actions](https://docs.github.com/en/actions) and [GitHub Models](https://docs.github.com/en/github-models), you can automate the execution of the script and creation of the comments. * Add the following workflow in your GitHub repository. .github/workflows/genai-prd.yml ```yaml name: genai pull request description on: pull_request: types: [ready_for_review, review_requested] concurrency: group: genai-pr-review-${{ github.workflow }}-${{ github.ref }} cancel-in-progress: true permissions: contents: read # permission to read the repository pull-requests: write # permission to write a comment models: read # permission to use github models jobs: describe: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: "22" - name: fetch base branch run: git fetch origin ${{ github.event.pull_request.base.ref }} - name: genaiscript prd continue-on-error: true run: npx --yes genaiscript run prd --vars base=origin/${{ github.event.pull_request.base.ref }} --pull-request-description --out-trace $GITHUB_STEP_SUMMARY env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} ``` The action triggers when the pull request is marked as `ready_for_review` or when a review is requested. ```yaml pull_request: types: [ready_for_review, review_requested] ``` The command line uses a special flag to update the generate pull request description: * `--pull-request-description` to update the description of the pull request We‚Äôve also added `continue-on-error: true` so that the workflow does not fail if the script fails. * Commit the changes, and create a new pull request and start testing the workflow by requesting a review or toggling the `ready_for_review` event. ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) Additional measures to further enhance safety would be to run [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validate the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety. ## Make it Agentic [Section titled ‚ÄúMake it Agentic‚Äù](#make-it-agentic) GenAIScript provides various builtin agents, including a file system and git agent. This can be useful for the LLM to read the files in the pull request and analyze them. There are basically two level of agentic-ness you can achieve with GenAIScript: ### Tools [Section titled ‚ÄúTools‚Äù](#tools) * add the [fs\_read\_file](/genaiscript/reference/scripts/system/#systemfs_read_file) to read files to the script. genaisrc/prd.genai.mts ```ts script({ ..., tools: ["fs_read_file"], }) ``` ### Agents [Section titled ‚ÄúAgents‚Äù](#agents) * add the [file system agent](/genaiscript/reference/scripts/system/#systemagent_fs) that can respond to more complex queries at the cost of additional tokens. genaisrc/prd.genai.mts ```ts script({ ..., tools: ["agent_fs"], }) ```

# Pull Request Reviewer

> Review the current files or changes

The following sample shows a script that analyzes the changes in a pull request and posts the comments in GitHub. We will develop the script locally and then create a GitHub Action to run it automatically. ## Add the script [Section titled ‚ÄúAdd the script‚Äù](#add-the-script) * Open your GitHub repository and start a new pull request. * Add the following script to your repository as `genaisrc/prr.genai.mts`. genaisrc/prr.genai.mts ```ts script({ title: "Pull Request Reviewer", description: "Review the current pull request", systemSafety: true, parameters: { base: "", }, }) const { dbg, vars } = env const base = vars.base || (await git.defaultBranch()) const changes = await git.diff({ base, llmify: true, }) if (!changes) cancel("No changes found in the pull request") dbg(`changes: %s`, changes) const gitDiff = def("GIT_DIFF", changes, { language: "diff", maxTokens: 14000, detectPromptInjection: "available", }) $`Report errors in ${gitDiff} using the annotation format. - Use best practices of the programming language of each file. - If available, provide a URL to the official documentation for the best practice. do NOT invent URLs. - Analyze ALL the code. Do not be lazy. This is IMPORTANT. - Use tools to read the entire file content to get more context - Do not report warnings, only errors. - Add suggestions if possible, skip if you are not sure about a fix. ` ``` * run the [GenAIScript cli](/genaiscript/reference/cli/) to add the type definition files and fix the syntax errors in the editor (optional). ```bash npx --yes genaiscript script fix ``` The script starts with a metadata section (`script({ ... })`) that defines the title, description, and system safety options. The script then uses the `git` tool to get the diff of the pull request and stores it in the `GIT_DIFF` variable. The script then uses the `$` template literal to generate a report based on the diff. The report includes best practices for the programming language of each file, and it is important to analyze all the code. The script also includes a note to use tools to read the entire file content to get more context and to avoid reporting warnings. ## Run the script locally [Section titled ‚ÄúRun the script locally‚Äù](#run-the-script-locally) Since you are already in a pull request, you can run with the script and tune the prompting to your needs. You can use the GenAIScript Visual Studio Code extension or use the cli. ```sh npx --yes genaiscript run prr ``` You will see an output similar to the following. In the output, you will find links to the run reports (markdown files), information about the model, preview of the messages and the token usage. Open the `trace` or `output` reports in your favorite Markdown viewer to inspect the results. This part of the development is fully local so it‚Äôs your opportunity to refine the prompting. ```text ‚îå‚îÄüí¨ github:gpt-4.1 ‚úâ 2 ~‚Üë1.4kt ‚îå‚îÄüìô system ‚îÇ## Safety: Jailbreak ‚îÇ... (85 lines) ‚îÇ- **Do NOT use function names starting with 'functions.'. ‚îÇ- **Do NOT respond with multi_tool_use**. ‚îå‚îÄüë§ user ‚îÇ<GIT_DIFF lang="diff"> ‚îÇ--- /dev/null ‚îÇ+++ .github/workflows/genai-pr-review.yml ‚îÇ@@ -0,0 +1,22 @@ ‚îÇ--- /dev/null ‚îÇ[1] +++ genaisrc/.gitignore ‚îÇ... (3 lines) ‚îÇReport errors in <GIT_DIFF> using the annotation format. ‚îÇ- Use best practices of the programming language of each file. ‚îÇ- If available, provide a URL to the official documentation for the best practice. do NOT invent URLs. ‚îÇ- Analyze ALL the code. Do not be lazy. This is IMPORTANT. ‚îÇ- Use tools to read the entire file content to get more context ‚îÇ- Do not report warnings, only errors. ::error file=.github/workflows/genai-pr-review.yml,line=1,endLine=22,code=missing_workflow_content::The workflow file is empty or missing mandatory workflow keys like `name`, `on`, and `jobs`. Every GitHub Actions workflow file must specify at least these top-level keys to define triggers and jobs. See official docs: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions ‚îî‚îÄüèÅ github:gpt-4.1 ‚úâ 2 3446ms ‚áÖ 1.9kt ‚Üë1.6kt ‚Üì223t 0.505¬¢ genaiscript: success > 3446ms ‚Üë1.6kt ‚Üì223t 538.62t/s 0.505¬¢ github:gpt-4.1-2025-04-14> 3446ms ‚Üë1.6kt ‚Üì223t 538.62t/s 0.505¬¢ trace: ... output: ... ``` ## Make it Agentic [Section titled ‚ÄúMake it Agentic‚Äù](#make-it-agentic) GenAIScript provides various builtin agents, including a file system and git agent. This can be useful for the LLM to read the files in the pull request and analyze them. There are basically two level of agentic-ness you can achieve with GenAIScript: * add the [fs\_read\_file](/genaiscript/reference/scripts/system/#systemfs_read_file) to read files to the script. genaisrc/prr.genai.mts ```ts script({ ..., tools: ["fs_read_file"], }) ``` * add the [file system agent](/genaiscript/reference/scripts/system/#systemagent_fs) that can respond to more complex queries at the cost of additional tokens. genaisrc/prr.genai.mts ```ts script({ ..., tools: ["agent_fs"], }) ``` ## Automate with GitHub Actions [Section titled ‚ÄúAutomate with GitHub Actions‚Äù](#automate-with-github-actions) Using [GitHub Actions](https://docs.github.com/en/actions) and [GitHub Models](https://docs.github.com/en/github-models), you can automate the execution of the script and creation of the comments. * Add the following workflow in your GitHub repository. .github/workflows/genai-pr-review\.yml ```yaml name: genai pull request review on: pull_request: types: [ready_for_review, review_requested] concurrency: group: genai-pr-review-${{ github.workflow }}-${{ github.ref }} cancel-in-progress: true permissions: contents: read # permission to read the repository pull-requests: write # permission to write a comment models: read # permission to use github models jobs: review: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: "22" - name: fetch base branch run: git fetch origin ${{ github.event.pull_request.base.ref }} - name: genaiscript prr run: npx --yes genaiscript run prr --vars base=origin/${{ github.event.pull_request.base.ref }} --pull-request-reviews --pull-request-comment --out-trace $GITHUB_STEP_SUMMARY env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} ``` The command line uses two special flags to generate pull request comments and reviews: * `--pull-request-reviews` to generate a pull request review comments from each annotation, * `--pull-request-comment` to generate a comment for the pull request from the output. * Commit the changes, and create a new pull request and start testing the workflow by requesting a review or toggling the `ready_for_review` event. ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) Additional measures to further enhance safety would be to run [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validate the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.

# Spell Checker

> Review documentation for spelling and grammar

This example showcases updating files and pushing a commit with the changes in a GitHub Action using GitHub Models. ## Add the script [Section titled ‚ÄúAdd the script‚Äù](#add-the-script) * Open your GitHub repository and start a new pull request. * Add the following script to your repository as `sc.genai.mts` in the `genaisrc` folder. genaisrc/sc.genai.mts ```ts script({ title: "Spell checker", system: ["system.output_plaintext", "system.assistant", "system.files"], responseType: "text", systemSafety: false, temperature: 0.2, parameters: { base: "", }, }) const { vars } = env const base = vars.base || "HEAD~1" console.debug(`base: ${base}`) let files = env.files.length ? env.files : await git.listFiles("modified-base", { base }) files = files.filter((f) => /\.mdx?$/.test(f.filename)) console.debug(`files: ${files.map((f) => f.filename).join("\n")}`) for (const file of files) { const { text, error, finishReason } = await runPrompt( (ctx) => { const fileRef = ctx.def("FILES", file) ctx.$`Fix the spelling and grammar of the content of ${fileRef}. Return the full file with corrections. If you find a spelling or grammar mistake, fix it. If you do not find any mistakes, respond <NO> and nothing else. - only fix major errors - use a technical documentation tone - minimize changes; do NOT change the meaning of the content - if the grammar is good enough, do NOT change it - do NOT modify the frontmatter. THIS IS IMPORTANT. - do NOT modify code regions. THIS IS IMPORTANT. - do NOT modify URLs - do NOT fix \`code\` and \`\`\`code\`\`\` sections - in .mdx files, do NOT fix inline TypeScript code ` }, { label: file.filename } ) if ( !text || file.content === text || error || finishReason !== "stop" || /<NO>/i.test(text) ) continue console.debug(`update ${file.filename}`) await workspace.writeText(file.filename, text) } ``` * run the [GenAIScript cli](/genaiscript/reference/cli/) to add the type definition files and fix the syntax errors in the editor (optional). ```bash npx --yes genaiscript script fix ``` The script collects the list of modified files in the last commit and filters them to only include `.md` and `.mdx` files. It then runs a prompt for each file, asking the LLM to fix spelling and grammar mistakes while preserving the content. The prompt includes instructions to avoid modifying the frontmatter, code regions, URLs, and inline TypeScript code in `.mdx` files. The script uses the `runPrompt` function to execute the prompt and handle the response. The response is then written back to the file if there are any changes. The script also includes a `system` section that defines the system prompts to be used in the script. ## Run the script locally [Section titled ‚ÄúRun the script locally‚Äù](#run-the-script-locally) You can run with the script and tune the prompting to your needs. You can use the GenAIScript Visual Studio Code extension or use the cli. ```sh npx --yes genaiscript run sc **/*.md ``` You will see an output similar to the following. In the output, you will find links to the run reports (markdown files), information about the model, preview of the messages and the token usage. Open the `trace` or `output` reports in your favorite Markdown viewer to inspect the results. This part of the development is fully local so it‚Äôs your opportunity to refine the prompting. ````text docs/src/content/docs/samples/prd.md ‚îå‚îÄüí¨ github:gpt-4.1 ‚úâ 2 ~‚Üë2.3kt ‚îå‚îÄüìô system ‚îÇ## Safety: Jailbreak ‚îÇ... (10 lines) ‚îÇ- do NOT respond in JSON. ‚îÇ- **do NOT wrap response in a 'markdown' code block!** ‚îå‚îÄüë§ user ‚îÇ<FILES lang="md" file="docs/src/content/docs/samples/prd.md"> ‚îÇ--- ‚îÇtitle: Pull Request Descriptor ‚îÇdescription: Generate a pull request description ‚îÇsidebar: ‚îÇ order: 5 ‚îÇ... (152 lines) ‚îÇ- if the grammar is good enough, do NOT change it ‚îÇ- do NOT modify the frontmatter. THIS IS IMPORTANT. ‚îÇ- do NOT modify code regions. THIS IS IMPORTANT. ‚îÇ- do NOT modify URLs ‚îÇ- do NOT fix `code` and ```code``` sections ‚îÇ- in .mdx files, do NOT fix inline typescript code --- title: Pull Request Descriptor description: Generate a pull request description ... ```` ## Automate with GitHub Actions [Section titled ‚ÄúAutomate with GitHub Actions‚Äù](#automate-with-github-actions) Using [GitHub Actions](https://docs.github.com/en/actions) and [GitHub Models](https://docs.github.com/en/github-models), you can automate the execution of the script. It will run on all modified markdown files outside the `main` branch. * Add the following workflow in your GitHub repository. .github/workflows/genai-sc.yml ```yaml name: genai sc on: push: branches-ignore: - main paths: - '**/*.md' - '**/*.mdx' concurrency: group: genai-sc-{{ github.workflow }}-${{ github.ref }} cancel-in-progress: true permissions: contents: write # permission to read the repository models: read # permission to use github models jobs: review: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - uses: actions/setup-node@v4 with: node-version: "22" - name: fetch previous commit run: git fetch origin ${{ github.event.before }} --depth=1 - name: genaiscript sc run: npx --yes genaiscript run sc --vars base="${{ github.event.before }}" --out-trace $GITHUB_STEP_SUMMARY env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} - name: Commit and push changes run: | git config user.name "github-actions[bot]" git config user.email "github-actions[bot]@users.noreply.github.com" git add -u if git diff --cached --quiet; then echo "No changes to commit." else git commit -m "fix: spellcheck markdown files [genai]" git pull origin $(git rev-parse --abbrev-ref HEAD) --ff-only git push fi ``` ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) Additional measures to further enhance safety would be to run [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validate the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.

# Search and transform

> Search for a pattern in files and apply an LLM transformation to the match

Search and Replace is a powerful tool in the developer‚Äôs tool-belt that can save you time and effort‚Ä¶ if you can formulate the right regular expression. **Search and Transform** is a twist on the same concept, but we use an LLM to perform the transformation instead of a simple string replacement. ### üë©‚Äçüíª Understanding the Script Code [Section titled ‚Äúüë©‚Äçüíª Understanding the Script Code‚Äù](#-understanding-the-script-code) ```ts script({ title: "Search and transform", description: "Search for a pattern in files and apply an LLM transformation to the match", parameters: { glob: { type: "string", description: "The glob pattern to filter files", default: "*", }, pattern: { type: "string", description: "The text pattern (regular expression) to search for", }, transform: { type: "string", description: "The LLM transformation to apply to the match", }, }, }) ``` The script starts by defining its purpose and parameters using the `script` function. Here, we define the title, description, and the three parameters the script will need: `glob` to specify the files, `pattern` for the text to search for, and `transform` for the desired transformation. ### Extracting and Validating Parameters [Section titled ‚ÄúExtracting and Validating Parameters‚Äù](#extracting-and-validating-parameters) ```ts const { pattern, glob, transform } = env.vars if (!pattern) cancel("pattern is missing") const patternRx = new RegExp(pattern, "g") if (!transform) cancel("transform is missing") ``` Next, we extract the `pattern`, `glob`, and `transform` parameters from the environment variables and validate them. If `pattern` or `transform` are missing, the script will cancel execution. We then compile the `pattern` into a regular expression object for later use. ### Searching for Files and Matches [Section titled ‚ÄúSearching for Files and Matches‚Äù](#searching-for-files-and-matches) ```ts const { files } = await workspace.grep(patternRx, glob) ``` Here, we use the `grep` function from the `workspace` API to search for files that match the `glob` pattern and contain the regex pattern. ### Transforming Matches [Section titled ‚ÄúTransforming Matches‚Äù](#transforming-matches) ```ts // cached computed transformations const patches = {} for (const file of files) { console.log(file.filename) const { content } = await workspace.readText(file.filename) // skip binary files if (!content) continue // compute transforms for (const match of content.matchAll(patternRx)) { console.log(` ${match[0]}`) if (patches[match[0]]) continue ``` We initialize an object called `patches` to store the transformations. Then, we loop through each file, read its content, and skip binary files. For each match found in the file‚Äôs content, we check if we‚Äôve already computed a transformation for this match to avoid redundant work. ### Generating Prompts for Transformations [Section titled ‚ÄúGenerating Prompts for Transformations‚Äù](#generating-prompts-for-transformations) ```ts const res = await runPrompt( (_) => { _.$` ## Task Your task is to transform the MATCH using the following TRANSFORM. Return the transformed text. - do NOT add enclosing quotes. ## Context ` _.def("MATCHED", match[0]) _.def("TRANSFORM", transform) }, { label: match[0], system: [], cache: "search-and-transform" } ) ``` For each unique match, we generate a prompt using the `runPrompt` function. In the prompt, we define the task and context for the transformation, specifying that the transformed text should be returned without enclosing quotes. We also define the matched text and the transformation to apply. ### Applying the Transformation [Section titled ‚ÄúApplying the Transformation‚Äù](#applying-the-transformation) ```ts const transformed = res.fences?.[0].content ?? res.text if (transformed) patches[match[0]] = transformed console.log(` ${match[0]} -> ${transformed ?? "?"}`) } // apply transforms const newContent = content.replace( patternRx, (match) => patches[match] ?? match ) ``` We then extract the transformed text from the prompt result and store it in the `patches` object. Finally, we apply the transformations to the file content using `String.prototype.replace`. ### Saving the Changes [Section titled ‚ÄúSaving the Changes‚Äù](#saving-the-changes) ```ts if (content !== newContent) await workspace.writeText(file.filename, newContent) } ``` If the file content has changed after applying the transformations, we save the updated content back to the file. ## Running the Script [Section titled ‚ÄúRunning the Script‚Äù](#running-the-script) To run this script, you‚Äôll need the GenAIScript CLI. Check out the [installation guide](https://microsoft.github.io/genaiscript/getting-started/installation) if you need to set it up. Once you have the CLI, run the script by executing: ```bash genaiscript run st ``` ## Full source ([GitHub](https://github.com/microsoft/genaiscript/blob/main/packages/sample/genaisrc/samples/st.genai.mts)) [Section titled ‚ÄúFull source (GitHub)‚Äù](#full-source-github) st.genai.mts ```ts script({ title: "Search and transform", description: "Search for a pattern in files and apply a LLM transformation the match", parameters: { glob: { type: "string", description: "The glob pattern to filter files", }, pattern: { type: "string", description: "The text pattern (regular expression) to search for", }, transform: { type: "string", description: "The LLM transformation to apply to the match", }, }, }) let { pattern, glob, transform } = env.vars if (!glob) glob = (await host.input( "Enter the glob pattern to filter files (default: *)" )) || "*" if (!pattern) pattern = await host.input( "Enter the pattern to search for (regular expression)" ) if (!pattern) cancel("pattern is missing") const patternRx = new RegExp(pattern, "g") if (!transform) transform = await host.input( "Enter the LLM transformation to apply to the match" ) if (!transform) cancel("transform is missing") const { files } = await workspace.grep(patternRx, { glob }) // cached computed transformations const patches = {} for (const file of files) { console.log(file.filename) const { content } = await workspace.readText(file.filename) // skip binary files if (!content) continue // compute transforms for (const match of content.matchAll(patternRx)) { console.log(` ${match[0]}`) if (patches[match[0]]) continue const res = await runPrompt( (_) => { _.$` ## Task Your task is to transform the MATCH with the following TRANSFORM. Return the transformed text. - do NOT add enclosing quotes. ## Context ` _.def("MATCHED", match[0]) _.def("TRANSFORM", transform, { detectPromptInjection: "available", }) }, { label: match[0], system: [ "system.assistant", "system.safety_jailbreak", "system.safety_harmful_content", ], cache: "search-and-transform", } ) const transformed = res.fences?.[0].content ?? res.text if (transformed) patches[match[0]] = transformed console.log(` ${match[0]} -> ${transformed ?? "?"}`) } // apply transforms const newContent = content.replace( patternRx, (match) => patches[match] ?? match ) // save results if file content is modified if (content !== newContent) await workspace.writeText(file.filename, newContent) } ``` ## Content Safety [Section titled ‚ÄúContent Safety‚Äù](#content-safety) The following measures are taken to ensure the safety of the generated content. * This script includes system prompts to prevent prompt injection and harmful content generation. * [system.safety\_jailbreak](/genaiscript/reference/scripts/system#systemsafety_jailbreak) * [system.safety\_harmful\_content](/genaiscript/reference/scripts/system#systemsafety_harmful_content) * The generated description is saved to a file at a specific path, which allows for manual review before committing the changes. Additional measures to further enhance safety include running [a model with a safety filter](https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/content-filter?tabs=warning%2Cuser-prompt%2Cpython-new) or validating the message with a [content safety service](/genaiscript/reference/scripts/content-safety). Refer to the [Transparency Note](/genaiscript/reference/transparency-note/) for more information on content safety.